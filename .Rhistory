unc_acc |>
summarize(v_unc_1 = sum(V_unc_i_1)/sum(O_i),
v_unc_2 = sum(V_unc_i_2)/sum(O_i),
v_unc_3 = sum(V_unc_i_3)/sum(O_i))
# Sum of the opportunities divided by the total population
LU |>
summarize(PPR = sum(D_j)/sum(O_i))
# Calculate the balancing factors/proportionality constants for each of three impedance functions
k_tot <- unc_acc_ij |>
summarize(k1 = sum(LU$D_j)/sum(V_unc_ij_1), # f_1
k2 = sum(LU$D_j)/sum(V_unc_ij_2), # f_2
k3 = sum(LU$D_j)/sum(V_unc_ij_3)) # f_3
#| label: tab-simple-example-total-opportunity-accessibility
#| tbl-cap: "Simple system: total opportunity constrained accessibility."
tot_acc_ij <- unc_acc_ij |>
mutate(V_tot_ij_1 = k_tot$k1 * V_unc_ij_1,
V_tot_ij_2 = k_tot$k2 * V_unc_ij_2,
V_tot_ij_3 = k_tot$k3 * V_unc_ij_3)
tot_acc <- tot_acc_ij |>
group_by(oid) |>
summarize(V_tot_i_1 = sum(V_tot_ij_1),
V_tot_i_2 = sum(V_tot_ij_2),
V_tot_i_3 = sum(V_tot_ij_3))
tot_acc |>
select(oid, starts_with("V_")) |>
gt(rowname_col = "oid") |>
tab_stubhead(label = "Origin") |>
tab_spanner(label = "{{V[_i^T]}}",
columns = 2:4,
level = 2) |>
tab_spanner(label = "{{f_1 (c_ij ) = 1/c[_ij^3]}}",
columns = 2,
level = 1) |>
tab_spanner(label = "{{f_2 (c_ij ) = 1/c[_ij^2]}}",
columns = 3,
level = 1) |>
tab_spanner(label = "{{f_3 (c_ij ) = 1/c[_ij^0.1]}}",
columns = 4,
level = 1) |>
fmt_number(decimals = 3) |>
cols_label(V_tot_i_1 = md("units: *physicians*"),
V_tot_i_2 = md("units: *physicians*"),
V_tot_i_3 = md("units: *physicians*"))  |>
cols_align(align = "center",
columns = 2:4) |>
cols_width(
stub() ~ px(60),
everything() ~ px(180)
) |>
tab_options(column_labels.font.size = "small") |>
as_latex()
tot_acc$V_tot_i_1[2] - tot_acc$V_tot_i_1[1]
tot_acc$V_tot_i_2[2] - tot_acc$V_tot_i_2[1]
tot_acc$V_tot_i_3[2] - tot_acc$V_tot_i_3[1]
tot_acc$V_tot_i_1[2]/tot_acc$V_tot_i_1[1]
tot_acc$V_tot_i_2[2]/tot_acc$V_tot_i_2[1]
tot_acc$V_tot_i_3[2]/tot_acc$V_tot_i_3[1]
tot_acc <- tot_acc |>
left_join(LU |>
select(-D_j),
by = c("oid" = "id"))
tot_acc  |>
summarize(V_tot_1 = sum(V_tot_i_1),
V_tot_2 = sum(V_tot_i_2),
V_tot_3 = sum(V_tot_i_3))
LU |>
summarize(O = sum(D_j))
# Accessibility divided by population
tot_acc |>
mutate(v_tot_1 = V_tot_i_1/O_i,
v_tot_2 = V_tot_i_2/O_i,
v_tot_3 = V_tot_i_3/O_i)
# Sum of the accessibility divided by the total population
tot_acc |>
summarize(v_tot_1 = sum(V_tot_i_1)/sum(O_i),
v_tot_2 = sum(V_tot_i_2)/sum(O_i),
v_tot_3 = sum(V_tot_i_3)/sum(O_i))
# Sum of the opportunities divided by the total population
LU |>
summarize(PPR = sum(D_j)/sum(O_i))
# Calculate the balancing factors/proportionality constants for each of three impedance functions
unc_market_ij <- OD |>
mutate(M_unc_ij_1 = O_i * f1,
M_unc_ij_2 = O_i * f2,
M_unc_ij_3 = O_i * f3)
k_tot_pop <- unc_market_ij |>
summarize(k1 = sum(LU$O_i)/sum(M_unc_ij_1), # f_1
k2 = sum(LU$O_i)/sum(M_unc_ij_2), # f_2
k3 = sum(LU$O_i)/sum(M_unc_ij_3)) # f_3
#| label: tab-simple-example-total-population-accessibility
#| tbl-cap: "Simple system: total opportunity constrained accessibility."
tot_pop_ij <- unc_market_ij |>
mutate(M_tot_ij_1 = k_tot_pop$k1 * M_unc_ij_1,
M_tot_ij_2 = k_tot_pop$k2 * M_unc_ij_2,
M_tot_ij_3 = k_tot_pop$k3 * M_unc_ij_3)
tot_market <- tot_pop_ij |>
group_by(did) |>
summarize(M_tot_i_1 = sum(M_tot_ij_1),
M_tot_i_2 = sum(M_tot_ij_2),
M_tot_i_3 = sum(M_tot_ij_3))
tot_market |>
select(did, starts_with("M_")) |>
gt(rowname_col = "did") |>
tab_stubhead(label = "Destination") |>
tab_spanner(label = "{{M[_i^D]}}",
columns = 2:4,
level = 2) |>
tab_spanner(label = "{{f_1 (c_ij ) = 1/c[_ij^3]}}",
columns = 2,
level = 1) |>
tab_spanner(label = "{{f_2 (c_ij ) = 1/c[_ij^2]}}",
columns = 3,
level = 1) |>
tab_spanner(label = "{{f_3 (c_ij ) = 1/c[_ij^0.1]}}",
columns = 4,
level = 1) |>
fmt_number(decimals = 3) |>
cols_label(M_tot_i_1 = md("units: *population in 10,000s*"),
M_tot_i_2 = md("units: *population in 10,000s*"),
M_tot_i_3 = md("units: *population in 10,000s*"))  |>
cols_align(align = "center",
columns = 2:4) |>
cols_width(
stub() ~ px(90),
everything() ~ px(150)
) |>
tab_options(column_labels.font.size = "small") |>
as_latex()
B_j <- OD |>
group_by(did) |>
summarize(B_j_1 = 1/sum(O_i * f1),
B_j_2 = 1/sum(O_i * f2),
B_j_3 = 1/sum(O_i * f3))
B_j
#| label: tab-simple-example-attraction-constrained-accessibility
#| tbl-cap: "Simple system: singly-constrained opportunity constrained accessibility."
opp_acc_ij <- OD |>
left_join(B_j,
by = "did") |>
mutate(V_opp_ij_1 = B_j_1 * O_i * D_j * f1,
V_opp_ij_2 = B_j_2 * O_i  * D_j * f2,
V_opp_ij_3 = B_j_3 * O_i  * D_j * f3)
opp_acc <- opp_acc_ij |>
group_by(oid) |>
summarize(V_opp_i_1 = sum(V_opp_ij_1),
V_opp_i_2 = sum(V_opp_ij_2),
V_opp_i_3 = sum(V_opp_ij_3))
opp_acc  |>
select(oid, starts_with("V_")) |>
gt(rowname_col = "oid") |>
tab_stubhead(label = "Origin") |>
tab_spanner(label = "{{V[_i^D]}}",
columns = 2:4,
level = 2) |>
tab_spanner(label = "{{f_1 (c_ij ) = 1/c[_ij^3]}}",
columns = 2,
level = 1) |>
tab_spanner(label = "{{f_2 (c_ij ) = 1/c[_ij^2]}}",
columns = 3,
level = 1) |>
tab_spanner(label = "{{f_3 (c_ij ) = 1/c[_ij^0.1]}}",
columns = 4,
level = 1) |>
fmt_number(decimals = 3) |>
cols_label(V_opp_i_1 = md("units: *physicians*"),
V_opp_i_2 = md("units: *physicians*"),
V_opp_i_3 = md("units: *physicians*"))  |>
cols_align(align = "center",
columns = 2:4) |>
cols_width(
stub() ~ px(60),
everything() ~ px(180)
) |>
tab_options(column_labels.font.size = "small") |>
as_latex()
opp_acc$V_opp_i_1[2] - opp_acc$V_opp_i_1[1]
opp_acc$V_opp_i_2[2] - opp_acc$V_opp_i_2[1]
opp_acc$V_opp_i_3[2] - opp_acc$V_opp_i_3[1]
opp_acc$V_opp_i_1[2] / opp_acc$V_opp_i_1[1]
opp_acc$V_opp_i_2[2] / opp_acc$V_opp_i_2[1]
opp_acc$V_opp_i_3[2] / opp_acc$V_opp_i_3[1]
opp_acc <- opp_acc |>
left_join(LU |>
select(-D_j),
by = c("oid" = "id"))
opp_acc  |>
summarize(V_opp_1 = sum(V_opp_i_1),
V_opp_2 = sum(V_opp_i_2),
V_opp_3 = sum(V_opp_i_3))
LU |>
summarize(O = sum(D_j))
# Accessibility divided by population
opp_acc |>
mutate(v_opp_1 = V_opp_i_1/O_i,
v_opp_2 = V_opp_i_2/O_i,
v_opp_3 = V_opp_i_3/O_i)
# Sum of the accessibility divided by the total population
opp_acc |>
summarize(v_opp_1 = sum(V_opp_i_1)/sum(O_i),
v_opp_2 = sum(V_opp_i_2)/sum(O_i),
v_opp_3 = sum(V_opp_i_3)/sum(O_i))
# Sum of the opportunities divided by the total population
LU |>
summarize(PPR = sum(D_j)/sum(O_i))
# Balancing factors $A_i$:
A_i <- OD |>
group_by(oid) |>
summarize(A_i_1 = 1/sum(D_j * f1),
A_i_2 = 1/sum(D_j * f2),
A_i_3 = 1/sum(D_j * f3))
A_i
#| label: tab-simple-example-production-constrained-accessibility
#| tbl-cap: "Simple system: singly-constrained population-constrained accessibility (market potential)."
pop_acc_ij <- OD |>
left_join(A_i,
by = "oid") |>
mutate(M_pop_ij_1 = A_i_1  * O_i * D_j * f1,
M_pop_ij_2 = A_i_2  * O_i * D_j * f2,
M_pop_ij_3 = A_i_3  * O_i * D_j * f3)
pop_acc <- pop_acc_ij |>
group_by(did) |>
summarize(M_pop_i_1 = sum(M_pop_ij_1),
M_pop_i_2 = sum(M_pop_ij_2),
M_pop_i_3 = sum(M_pop_ij_3))
pop_acc  |>
select(did, starts_with("M_")) |>
gt(rowname_col = "did") |>
tab_stubhead(label = "Destination") |>
tab_spanner(label = "{{M[_j^P]}}",
columns = 2:4,
level = 2) |>
tab_spanner(label = "{{f_1 (c_ij ) = 1/c[_ij^3]}}",
columns = 2,
level = 1) |>
tab_spanner(label = "{{f_2 (c_ij ) = 1/c[_ij^2]}}",
columns = 3,
level = 1) |>
tab_spanner(label = "{{f_3 (c_ij ) = 1/c[_ij^0.1]}}",
columns = 4,
level = 1) |>
fmt_number(decimals = 3) |>
cols_label(M_pop_i_1 = md("units: *population in 10,000s*"),
M_pop_i_2 = md("units: *population in 10,000s*"),
M_pop_i_3 = md("units: *population in 10,000s*"))  |>
cols_align(align = "center",
columns = 2:4) |>
cols_width(
stub() ~ px(90),
everything() ~ px(150)
) |>
tab_options(column_labels.font.size = "small") |>
as_latex()
pop_acc$M_pop_i_1[2] - pop_acc$M_pop_i_1[1]
pop_acc$M_pop_i_2[2] - pop_acc$M_pop_i_2[1]
pop_acc$M_pop_i_3[2] - pop_acc$M_pop_i_3[1]
pop_acc$M_pop_i_1[2] / pop_acc$M_pop_i_1[1]
pop_acc$M_pop_i_2[2] / pop_acc$M_pop_i_2[1]
pop_acc$M_pop_i_3[2] / pop_acc$M_pop_i_3[1]
pop_acc <- pop_acc |>
left_join(LU |>
select(-O_i),
by = c("did" = "id"))
pop_acc  |>
summarize(M_pop_1 = sum(M_pop_i_1),
M_pop_2 = sum(M_pop_i_2),
M_pop_3 = sum(M_pop_i_3))
LU |>
summarize(O = sum(O_i))
# Accessibility divided by population
pop_acc |>
mutate(m_pop_1 = M_pop_i_1/O_i,
m_pop_2 = M_pop_i_2/O_i,
m_pop_3 = M_pop_i_3/O_i)
# Sum of the accessibility divided by the total population
pop_acc |>
summarize(m_pop_1 = sum(M_pop_i_1)/sum(D_j),
m_pop_2 = sum(M_pop_i_2)/sum(D_j),
m_pop_3 = sum(M_pop_i_3)/sum(D_j))
# Sum of the opportunities divided by the total population
LU |>
summarize(PPR = sum(O_i))/sum(D_j)
#| label: simple-numerical-example-doubly-constrained
# Same as before
id <- c("1", "2", "3")
O_i2 <- c(4, 10, 6)
D_j2 <- c(160, 150, 180)
# Balance the sum of origins and destinations
f <- sum(O_i2 * 10000)/sum(D_j2)
D_j2 <- (f * D_j2/10000) |>
round()
LU2 <- data.frame(id, O_i2, D_j2)
#| label: tbl-small-system-land-use-doubly-constrained
#| tbl-cap: "Simple system with three zones. Population is in 10,000 persons and opportunities in 10,000s physicians."
LU2 |>
gt() |>
cols_label(id = "ID",
O_i2 = "Population",
D_j2 = "Opportunities")  |>
cols_align(align = "center",
columns = 2:3) |>
tab_footnote(footnote = md("Population is *Wi^(1)^* when used as a proxy for the mass at the origin, and *Oi* when used as a constraint."),
locations = cells_column_labels(columns = O_i2)) |>
tab_footnote(footnote = md("Opportunities is *Wj^(2)^* when used as a proxy for the mass at the destination, and *Dj* when used as a constraint."),
locations = cells_column_labels(columns = D_j2)) #|>
#as_latex()
#| label: simple-numerical-example-OD-table-doubly-constrained
OD2 <- C |>
left_join(LU2 |>
select(-D_j2),
by = c("oid" = "id")) |>
left_join(LU2 |>
select(-O_i2),
by = c("did" = "id"))
doubly_constrained_gravity_model <- function(
#CREDIT: I converted the python code from (https://github.com/SadraDaneshvar/Gravity_Model) to R
O,  # Origin production weights vector
D,  # Destination attraction weights vector
impedance_matrix,  # the resulting travel cost impedance matrix
error_threshold = 0.001,  # Error threshold for stopping condition
improvement_threshold = 1e-6  # Improvement threshold for stopping condition
) {
# Normalize O and D
sum_O <- sum(O)
sum_D <- sum(D)
cat("Checking production, attraction balancing:\n")
cat("Production: ", sum_O, "\n")
cat("Attraction: ", sum_D, "\n")
if (sum_O != sum_D) {
cat("Productions and attractions do not balance, scaling to match.\n")
if (sum_O < sum_D) {
O <- O * (sum_D / sum_O)
} else {
D <- D * (sum_O / sum_D)
}
} else {
cat("Production, attraction balancing OK.\n")
}
n <- length(O)  # Number of i
T <- sum(O)  # Total trips
Ai <- rep(1, n)  # Initialize Ai
Bj <- rep(1, n)  # Initialize Bj
previous_error <- Inf
iteration_count <- 0
stop_reason <- ""
while (TRUE) {
iteration_count <- iteration_count + 1
# Update Ai
for (i in 1:n) {
Ai[i] <- 1 / (sum(Bj * D * impedance_matrix[i, ]) + 1e-9)
}
# Update Bj
Bj_new <- rep(1, n)
for (j in 1:n) {
Bj_new[j] <- 1 / (sum(Ai * O * impedance_matrix[, j]) + 1e-9)
}
# Calculate Tij
Tij <- outer(Ai * O, Bj_new * D) * impedance_matrix #Tij <- outer(Ai * O, Bj_new * D) * impedance_matrix
# Print Ai and Bj for this iteration
cat("\nIteration:", iteration_count, "\n")
cat("Ai:", round(Ai, 3), "\n")
cat("Bj:", round(Bj_new, 3), "\n")
# Calculate error
error <- (sum(abs(O - rowSums(Tij))) + sum(abs(D - colSums(Tij)))) / T
# Calculate change in error
error_change <- abs(previous_error - error)
# Check stopping conditions
if (error < error_threshold) {
stop_reason <- "Error threshold met"
break
} else if (error_change < improvement_threshold) {
stop_reason <- "Slow improvement"
break
}
previous_error <- error
Bj <- Bj_new
}
# report stopping condition and final error threshold
cat("\nStopping Condition: ", stop_reason, "\n")
cat(sprintf("Final Error: %.3f%%\n", error * 100))
return(list(Ai = Ai, Bj = Bj, Tij = Tij))
}
Impf1 <- C$f1 |>
matrix(nrow = 3, ncol = 3)
Impf2 <- C$f2 |>
matrix(nrow = 3, ncol = 3)
Impf3 <- C$f3 |>
matrix(nrow = 3, ncol = 3)
dc_acc_1 <- doubly_constrained_gravity_model(O_i2, D_j2, Impf1)
dc_acc_2 <- doubly_constrained_gravity_model(O_i2, D_j2, Impf2)
dc_acc_3 <- doubly_constrained_gravity_model(O_i2, D_j2, Impf3)
A_i_doubly <- dc_acc_1$Ai
B_j_doubly <- dc_acc_2$Bj
A_i_doubly |> matrix()
B_j_doubly |> matrix() |> t()
LU |>
gt() |>
# tab_spanner("{{W[_i^(1)]}}",
#             columns = 2) |>
# tab_spanner("{{W[_j^(2)]}}",
#             columns = 3) |>
cols_label(id = "ID",
O_i = "Population",
D_j = "Opportunities")  |>
cols_align(align = "center",
columns = 2:3) |>
tab_footnote(footnote = md("Population is *Wi^(1)^* when used as a proxy for the mass at the origin, and *Oi* when used as a constraint."),
locations = cells_column_labels(columns = O_i)) |>
tab_footnote(footnote = md("Opportunities is *Wj^(2)^* when used as a proxy for the mass at the destination, and *Dj* when used as a constraint."),
locations = cells_column_labels(columns = D_j)) |>
as_latex()
sum(LU$D_j) / sum(LU$O_i)
sum(LU$D_j) / sum(LU$O_i)
unc_acc$V_unc_i_1[2] - unc_acc$V_unc_i_1[1]
unc_acc$V_unc_i_2[2] - unc_acc$V_unc_i_2[1]
unc_acc$V_unc_i_3[2] - unc_acc$V_unc_i_3[1]
unc_acc$V_unc_i_1[2]/unc_acc$V_unc_i_1[1]
View(unc_acc)
View(unc_acc_ij)
View(OD)
V_unc_i_1[2]
unc_acc$V_unc_i_1[3]
unc_acc$V_unc_i_1[3]
unc_acc$V_unc_i_1[3]
unc_acc <- unc_acc |>
left_join(LU |>
select(-D_j),
by = c("oid" = "id"))
unc_acc  |>
summarize(V_unc_1 = sum(V_unc_i_1),
V_unc_2 = sum(V_unc_i_2),
V_unc_3 = sum(V_unc_i_3))
LU |>
summarize(O = sum(D_j))
1/100
1/(10^3)
1/(10^2)
1/(10^0.1)
unc_acc$V_unc_i_1[3] - unc_acc$V_unc_i_1[1]
unc_acc$V_unc_i_3[1] - unc_acc$V_unc_i_1[1]
unc_acc$V_unc_i_1[2] - unc_acc$V_unc_i_1[1]
unc_acc$V_unc_i_1[1] - unc_acc$V_unc_i_1[3]
unc_acc$V_unc_i_3[1] - unc_acc$V_unc_i_3[2]
unc_acc$V_unc_i_3[1] - unc_acc$V_unc_i_3[3]
unc_acc$V_unc_i_1[1] - unc_acc$V_unc_i_1[2]
unc_acc$V_unc_i_1[1] - unc_acc$V_unc_i_1[3]
unc_acc$V_unc_i_1[1]/unc_acc$V_unc_i_1[2]
unc_acc$V_unc_i_3[1]/unc_acc$V_unc_i_3[2]
unc_acc$V_unc_i_3[1]/unc_acc$V_unc_i_3[3]
unc_acc$V_unc_i_1[1]/unc_acc$V_unc_i_1[2]
unc_acc$V_unc_i_1[1]/unc_acc$V_unc_i_1[3]
k_tot <- unc_acc_ij |>
summarize(k1 = sum(LU$D_j)/sum(V_unc_ij_1), # f_1
k2 = sum(LU$D_j)/sum(V_unc_ij_2), # f_2
k3 = sum(LU$D_j)/sum(V_unc_ij_3)) # f_3
k_tot
tot_acc$V_tot_i_1[1]
tot_acc$V_tot_i_1[2]
tot_acc$V_tot_i_1[3]
For instance at zone 1, using $f_1(c_{ij})$, $f_2(c_{ij})$, and $f_3(c_{ij})$ yields `r tot_acc$V_tot_i_1[1]`, `r tot_acc$V_tot_i_1[2]` and `r tot_acc$V_tot_i_1[3]` proportional-impedance-weighted physicians (effectively, simply in units of physicians), respectively. At zone 1, the difference between the least decay ($f_3(c_{ij})$) and most decay ($f_1(c_{ij})$) groups is `r tot_acc$V_tot_i_3[1] - tot_acc$V_tot_i_1[1]`, but in what units? These two values, though representing the same zone but different groups in that zone, have different units so this difference value cannot be meaningfully interpreted.
tot_acc$V_tot_i_3[1] - tot_acc$V_tot_i_1[1]
View(tot_acc)
View(tot_acc_ij)
For instance at zone 1, using $f_1(c_{ij})$, $f_2(c_{ij})$, and $f_3(c_{ij})$ yields `r tot_acc$V_tot_i_1[1]`, `r tot_acc$V_tot_i_1[2]` and `r tot_acc$V_tot_i_1[3]` proportional-impedance-weighted physicians (effectively, simply in units of physicians), respectively. At zone 1, the difference between the least decay ($f_3(c_{ij})$) and most decay ($f_1(c_{ij})$) groups is actually negative, with the least decaying group capturing `tot_acc$V_tot_i_1[1]-r tot_acc$V_tot_i_3[1]`, but in what units? These two values, though representing the same zone but different groups in that zone, have different units so this difference value cannot be meaningfully interpreted.
tot_acc$V_tot_i_1[1] - tot_acc$V_tot_i_1[3]
tot_acc$V_tot_i_1[1] - tot_acc$V_tot_i_1[3]
For instance at zone 1, using $f_1(c_{ij})$, $f_2(c_{ij})$, and $f_3(c_{ij})$ yields `r tot_acc$V_tot_i_1[1]`, `r tot_acc$V_tot_i_1[2]` and `r tot_acc$V_tot_i_1[3]` proportional-impedance-weighted physicians (effectively, simply in units of physicians), respectively. At zone 1, the difference between the least decay ($f_3(c_{ij})$) and most decay ($f_1(c_{ij})$) groups is actually negative, with the least decaying group capturing `tot_acc$V_tot_i_1[1]-r tot_acc$V_tot_i_3[1]`, but in what units? These two values, though representing the same zone but different groups in that zone, have different units so this difference value cannot be meaningfully interpreted.
tot_acc$V_tot_i_1[1]-r tot_acc$V_tot_i_3[1]
tot_acc$V_tot_i_1[1]- tot_acc$V_tot_i_3[1]
tot_acc$V_tot_i_1[1]/tot_acc$V_tot_i_1[2]
tot_acc$V_tot_i_1[1]/tot_acc$V_tot_i_1[3]
1/10^3
1/10^0.1
r tot_acc$V_tot_i_1 |> sum()
tot_acc$V_tot_i_1 |> sum()
tot_acc$V_tot_i_1[1]/tot_acc$V_tot_i_1[2]
tot_acc$V_tot_i_1[1]/tot_acc$V_tot_i_1[3]
tot_acc$V_tot_i_1[1]
tot_acc$V_tot_i_1[1]- tot_acc$V_tot_i_3[1]
tot_acc$V_tot_i_1[1]- tot_acc$V_tot_i_3[1]
tot_acc$V_tot_i_1[1]- tot_acc$V_tot_i_3[1]
tot_acc$V_tot_i_1[1]- tot_acc$V_tot_i_2[1]
tot_acc$V_tot_i_2 |> sum()
LU |>
summarize(O = sum(D_j))
tot_acc$V_tot_i_1[2] - tot_acc$V_tot_i_1[1]
tot_acc$V_tot_i_1[1]- tot_acc$V_tot_i_3[1]
tot_acc$V_tot_i_1[1]- tot_acc$V_tot_i_3[1]
View(k_tot_pop)
B_j
B_j_longer <- B_j
colnames(B_j_longer) <- c("ID","B_1","B_2","B_3")
B_j_longer |> as.data.frame()  |> gt(rownames_to_stub=TRUE)
B_j_longer |> as.data.frame()  |> gt(rownames_to_stub=FALSE)
B_j
B_j$B_j_2[1]
B_j$B_j_2[2]
opp_acc$V_opp_i_1[2] - opp_acc$V_opp_i_1[1]
opp_acc$V_opp_i_2[2] - opp_acc$V_opp_i_2[1]
opp_acc$V_opp_i_3[2] - opp_acc$V_opp_i_3[1]
opp_acc$V_opp_i_1[2] / opp_acc$V_opp_i_1[1]
opp_acc$V_opp_i_2[2] / opp_acc$V_opp_i_2[1]
opp_acc$V_opp_i_3[2] / opp_acc$V_opp_i_3[1]
opp_acc <- opp_acc |>
left_join(LU |>
select(-D_j),
by = c("oid" = "id"))
opp_acc  |>
summarize(V_opp_1 = sum(V_opp_i_1),
V_opp_2 = sum(V_opp_i_2),
V_opp_3 = sum(V_opp_i_3))
LU |>
summarize(O = sum(D_j))
