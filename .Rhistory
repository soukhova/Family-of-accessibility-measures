cat("Checking production, attraction balancing:\n")
cat("Production: ", sum_O, "\n")
cat("Attraction: ", sum_D, "\n")
if (sum_O != sum_D) {
cat("Productions and attractions do not balance, scaling to match.\n")
if (sum_O < sum_D) {
O <- O * (sum_D / sum_O)
} else {
D <- D * (sum_O / sum_D)
}
} else {
cat("Production, attraction balancing OK.\n")
}
n <- length(O)  # Number of i
T <- sum(O)  # Total trips
Ai <- rep(1, n)  # Initialize Ai
Bj <- rep(1, n)  # Initialize Bj
previous_error <- Inf
iteration_count <- 0
stop_reason <- ""
while (TRUE) {
iteration_count <- iteration_count + 1
# Update Ai
for (i in 1:n) {
Ai[i] <- 1 / (sum(Bj * D * impedance_matrix[i, ]) + 1e-9)
}
# Update Bj
Bj_new <- rep(1, n)
for (j in 1:n) {
Bj_new[j] <- 1 / (sum(Ai * O * impedance_matrix[, j]) + 1e-9)
}
# Calculate Tij
Tij <- outer(Ai * O, Bj_new * D) * impedance_matrix
# Print Ai and Bj for this iteration
cat("\nIteration:", iteration_count, "\n")
cat("Ai:", round(Ai, 3), "\n")
cat("Bj:", round(Bj_new, 3), "\n")
# Calculate error
error <- (sum(abs(O - rowSums(Tij))) + sum(abs(D - colSums(Tij)))) / T
# Calculate change in error
error_change <- abs(previous_error - error)
# Check stopping conditions
if (error < error_threshold) {
stop_reason <- "Error threshold met"
break
} else if (error_change < improvement_threshold) {
stop_reason <- "Slow improvement"
break
}
previous_error <- error
Bj <- Bj_new
}
# Format and print final results
return(Tij)
cat("\nNumber of Iterations: ", iteration_count, "\n")
cat("Stopping Condition: ", stop_reason, "\n")
cat(sprintf("Final Error: %.3f%%\n", error * 100))
}
t <- gravity_model(O=W_i, D=W_j, impedance_matrix = 1/C)
t
rm(t)
gravity_model(O=W_i, D=W_j, impedance_matrix = 1/C)
return(Tij)
gravity_model <- function(
#CREDIT: I converted the python code from (https://github.com/SadraDaneshvar/Gravity_Model) to R
O,  # Origin production weights vector
D,  # Destination attraction weights vector
impedance_matrix,  # the resulting travel cost impedance matrix
error_threshold = 0.001,  # Error threshold for stopping condition
improvement_threshold = 1e-6  # Improvement threshold for stopping condition
) {
# Normalize O and D
sum_O <- sum(O)
sum_D <- sum(D)
cat("Checking production, attraction balancing:\n")
cat("Production: ", sum_O, "\n")
cat("Attraction: ", sum_D, "\n")
if (sum_O != sum_D) {
cat("Productions and attractions do not balance, scaling to match.\n")
if (sum_O < sum_D) {
O <- O * (sum_D / sum_O)
} else {
D <- D * (sum_O / sum_D)
}
} else {
cat("Production, attraction balancing OK.\n")
}
n <- length(O)  # Number of i
T <- sum(O)  # Total trips
Ai <- rep(1, n)  # Initialize Ai
Bj <- rep(1, n)  # Initialize Bj
previous_error <- Inf
iteration_count <- 0
stop_reason <- ""
while (TRUE) {
iteration_count <- iteration_count + 1
# Update Ai
for (i in 1:n) {
Ai[i] <- 1 / (sum(Bj * D * impedance_matrix[i, ]) + 1e-9)
}
# Update Bj
Bj_new <- rep(1, n)
for (j in 1:n) {
Bj_new[j] <- 1 / (sum(Ai * O * impedance_matrix[, j]) + 1e-9)
}
# Calculate Tij
Tij <- outer(Ai * O, Bj_new * D) * impedance_matrix
# Print Ai and Bj for this iteration
cat("\nIteration:", iteration_count, "\n")
cat("Ai:", round(Ai, 3), "\n")
cat("Bj:", round(Bj_new, 3), "\n")
# Calculate error
error <- (sum(abs(O - rowSums(Tij))) + sum(abs(D - colSums(Tij)))) / T
# Calculate change in error
error_change <- abs(previous_error - error)
# Check stopping conditions
if (error < error_threshold) {
stop_reason <- "Error threshold met"
break
} else if (error_change < improvement_threshold) {
stop_reason <- "Slow improvement"
break
}
previous_error <- error
Bj <- Bj_new
}
# Format and print final results
# final_matrix <- data.frame(Tij)
# rownames(final_matrix) <- paste0("Zone ", 1:n)
# colnames(final_matrix) <- paste0("Zone ", 1:n)
# final_matrix$Origin <- rowSums(final_matrix)
# final_matrix["Destination", ] <- c(colSums(final_matrix), sum(Tij))
#
# cat("\nFinal OD Matrix:\n")
# print(round(final_matrix, 3))
cat("\nNumber of Iterations: ", iteration_count, "\n")
cat("Stopping Condition: ", stop_reason, "\n")
cat(sprintf("Final Error: %.3f%%\n", error * 100))
return(Tij)
}
gravity_model(O=W_i, D=W_j, impedance_matrix = 1/C)
#t
rm(t)
gravity_model <- function(
#CREDIT: I converted the python code from (https://github.com/SadraDaneshvar/Gravity_Model) to R
O,  # Origin production weights vector
D,  # Destination attraction weights vector
impedance_matrix,  # the resulting travel cost impedance matrix
error_threshold = 0.001,  # Error threshold for stopping condition
improvement_threshold = 1e-6  # Improvement threshold for stopping condition
) {
# Normalize O and D
sum_O <- sum(O)
sum_D <- sum(D)
cat("Checking production, attraction balancing:\n")
cat("Production: ", sum_O, "\n")
cat("Attraction: ", sum_D, "\n")
if (sum_O != sum_D) {
cat("Productions and attractions do not balance, scaling to match.\n")
if (sum_O < sum_D) {
O <- O * (sum_D / sum_O)
} else {
D <- D * (sum_O / sum_D)
}
} else {
cat("Production, attraction balancing OK.\n")
}
n <- length(O)  # Number of i
T <- sum(O)  # Total trips
Ai <- rep(1, n)  # Initialize Ai
Bj <- rep(1, n)  # Initialize Bj
previous_error <- Inf
iteration_count <- 0
stop_reason <- ""
while (TRUE) {
iteration_count <- iteration_count + 1
# Update Ai
for (i in 1:n) {
Ai[i] <- 1 / (sum(Bj * D * impedance_matrix[i, ]) + 1e-9)
}
# Update Bj
Bj_new <- rep(1, n)
for (j in 1:n) {
Bj_new[j] <- 1 / (sum(Ai * O * impedance_matrix[, j]) + 1e-9)
}
# Calculate Tij
Tij <- outer(Ai * O, Bj_new * D) * impedance_matrix
# Print Ai and Bj for this iteration
cat("\nIteration:", iteration_count, "\n")
cat("Ai:", round(Ai, 3), "\n")
cat("Bj:", round(Bj_new, 3), "\n")
# Calculate error
error <- (sum(abs(O - rowSums(Tij))) + sum(abs(D - colSums(Tij)))) / T
# Calculate change in error
error_change <- abs(previous_error - error)
# Check stopping conditions
if (error < error_threshold) {
stop_reason <- "Error threshold met"
break
} else if (error_change < improvement_threshold) {
stop_reason <- "Slow improvement"
break
}
previous_error <- error
Bj <- Bj_new
}
# report stopping condition and final error threshold
cat("Stopping Condition: ", stop_reason, "\n")
cat(sprintf("Final Error: %.3f%%\n", error * 100))
return(Tij)
}
gravity_model(O=W_i, D=W_j, impedance_matrix = 1/C)
gravity_model <- function(
#CREDIT: I converted the python code from (https://github.com/SadraDaneshvar/Gravity_Model) to R
O,  # Origin production weights vector
D,  # Destination attraction weights vector
impedance_matrix,  # the resulting travel cost impedance matrix
error_threshold = 0.001,  # Error threshold for stopping condition
improvement_threshold = 1e-6  # Improvement threshold for stopping condition
) {
# Normalize O and D
sum_O <- sum(O)
sum_D <- sum(D)
cat("Checking production, attraction balancing:\n")
cat("Production: ", sum_O, "\n")
cat("Attraction: ", sum_D, "\n")
if (sum_O != sum_D) {
cat("Productions and attractions do not balance, scaling to match.\n")
if (sum_O < sum_D) {
O <- O * (sum_D / sum_O)
} else {
D <- D * (sum_O / sum_D)
}
} else {
cat("Production, attraction balancing OK.\n")
}
n <- length(O)  # Number of i
T <- sum(O)  # Total trips
Ai <- rep(1, n)  # Initialize Ai
Bj <- rep(1, n)  # Initialize Bj
previous_error <- Inf
iteration_count <- 0
stop_reason <- ""
while (TRUE) {
iteration_count <- iteration_count + 1
# Update Ai
for (i in 1:n) {
Ai[i] <- 1 / (sum(Bj * D * impedance_matrix[i, ]) + 1e-9)
}
# Update Bj
Bj_new <- rep(1, n)
for (j in 1:n) {
Bj_new[j] <- 1 / (sum(Ai * O * impedance_matrix[, j]) + 1e-9)
}
# Calculate Tij
Tij <- outer(Ai * O, Bj_new * D) * impedance_matrix
# Print Ai and Bj for this iteration
cat("\nIteration:", iteration_count, "\n")
cat("Ai:", round(Ai, 3), "\n")
cat("Bj:", round(Bj_new, 3), "\n")
# Calculate error
error <- (sum(abs(O - rowSums(Tij))) + sum(abs(D - colSums(Tij)))) / T
# Calculate change in error
error_change <- abs(previous_error - error)
# Check stopping conditions
if (error < error_threshold) {
stop_reason <- "Error threshold met"
break
} else if (error_change < improvement_threshold) {
stop_reason <- "Slow improvement"
break
}
previous_error <- error
Bj <- Bj_new
}
# report stopping condition and final error threshold
cat("Stopping Condition: ", stop_reason, "\n")
cat(sprintf("Final Error: %.3f%%\n", error * 100))
Tij
}
gravity_model(O=W_i, D=W_j, impedance_matrix = 1/C)
t <- gravity_model(O=W_i, D=W_j, impedance_matrix = 1/C)
t
t <- gravity_model(O=W_i, D=W_j, impedance_matrix = 1/C)
t
gravity_model <- function(
#CREDIT: I converted the python code from (https://github.com/SadraDaneshvar/Gravity_Model) to R
O,  # Origin production weights vector
D,  # Destination attraction weights vector
impedance_matrix,  # the resulting travel cost impedance matrix
error_threshold = 0.001,  # Error threshold for stopping condition
improvement_threshold = 1e-6  # Improvement threshold for stopping condition
) {
# Normalize O and D
sum_O <- sum(O)
sum_D <- sum(D)
cat("Checking production, attraction balancing:\n")
cat("Production: ", sum_O, "\n")
cat("Attraction: ", sum_D, "\n")
if (sum_O != sum_D) {
cat("Productions and attractions do not balance, scaling to match.\n")
if (sum_O < sum_D) {
O <- O * (sum_D / sum_O)
} else {
D <- D * (sum_O / sum_D)
}
} else {
cat("Production, attraction balancing OK.\n")
}
n <- length(O)  # Number of i
T <- sum(O)  # Total trips
Ai <- rep(1, n)  # Initialize Ai
Bj <- rep(1, n)  # Initialize Bj
previous_error <- Inf
iteration_count <- 0
stop_reason <- ""
while (TRUE) {
iteration_count <- iteration_count + 1
# Update Ai
for (i in 1:n) {
Ai[i] <- 1 / (sum(Bj * D * impedance_matrix[i, ]) + 1e-9)
}
# Update Bj
Bj_new <- rep(1, n)
for (j in 1:n) {
Bj_new[j] <- 1 / (sum(Ai * O * impedance_matrix[, j]) + 1e-9)
}
# Calculate Tij
Tij <- outer(Ai * O, Bj_new * D) * impedance_matrix
# Print Ai and Bj for this iteration
cat("\nIteration:", iteration_count, "\n")
cat("Ai:", round(Ai, 3), "\n")
cat("Bj:", round(Bj_new, 3), "\n")
# Calculate error
error <- (sum(abs(O - rowSums(Tij))) + sum(abs(D - colSums(Tij)))) / T
# Calculate change in error
error_change <- abs(previous_error - error)
# Check stopping conditions
if (error < error_threshold) {
stop_reason <- "Error threshold met"
break
} else if (error_change < improvement_threshold) {
stop_reason <- "Slow improvement"
break
}
previous_error <- error
Bj <- Bj_new
}
# report stopping condition and final error threshold
cat("\nStopping Condition: ", stop_reason, "\n")
cat(sprintf("Final Error: %.3f%%\n", error * 100))
}
t <- gravity_model(O=W_i, D=W_j, impedance_matrix = 1/C)
renv::status()
renv::status()
renv::snapshot()
#| label: load packages
library(bibliometrix) # Comprehensive Science Mapping Analysis
library(dplyr) # A Grammar of Data Manipulation
library(ggplot2) # Create Elegant Data Visualisations Using the Grammar of Graphics
library(ggraph) # An Implementation of Grammar of Graphics for Graphs and Networks
library(glue) # Interpreted String Literals
library(here) # A Simpler Way to Find Your Files
library(tidytext)
load(glue::glue(here::here(),
"/data/corpus.rda"))
A <- cocMatrix(corpus,
Field = "CR",
sep = ";")
View(A)
View(corpus)
B <- tcrossprod(A)
B_nd <- B - Matrix::band(B, 0, 0)
B_nd[1:10, 1:10]
View(corpus)
corpis$CR[1,]
corpus$CR[1,]
corpus$CR[,1]
corpus$CR[,]
corpus$CR
coupling_net <- igraph::graph_from_adjacency_matrix(B,
mode = "directed",
weighted = TRUE,
diag = FALSE)
rm(A)
coupling_net <- tidygraph::as_tbl_graph(coupling_net)
coupling_net
coupling_net <- coupling_net |>
tidygraph::activate("nodes") |>
left_join(tibble::rownames_to_column(corpus,
var = "rowname") |>
transmute(rowname,
corpus = corpus),
by = c("name" = "rowname"))
set.seed(979834789)
#set.seed(97389)
#set.seed(973899887)
coupling_net <- coupling_net |>
mutate(community = as.factor(tidygraph::group_infomap(weights = weight)))
layout <- create_layout(coupling_net,
layout = "stress",
weights = weight)
ggplot(data = layout) +
geom_point(aes(x = x,
y = y,
shape = corpus,
color = corpus),
size = 3,
alpha = 0.7) +
geom_point(data = layout |>
filter(corpus == "Both"),
aes(x = x,
y = y),
shape = 1,
size = 3) +
geom_point(data = layout |>
filter(corpus == "Wilson"),
aes(x = x,
y = y),
shape = 0,
size = 3,
alpha = 0.5) +
theme_void()
layout |>
filter(corpus == "Hansen") |>
summarize(x = mean(x),
y = mean(y))
hansen_names <- rownames(corpus |>
filter(corpus == "Hansen"))
wilson_names <- rownames(corpus |>
filter(corpus == "Wilson"))
both_names <- rownames(corpus |>
filter(corpus == "Both"))
hansen_to_wilson <- B_nd[hansen_names, wilson_names]
hansen_to_hansen <- B_nd[hansen_names, hansen_names]
wilson_to_wilson <- B_nd[wilson_names, wilson_names]
both_to_both <- B_nd[both_names, both_names]
both_to_hansen <- B_nd[both_names, hansen_names]
both_to_wilson <- B_nd[both_names, wilson_names]
sum(sum(B_nd))/(dim(B_nd)[1] * (dim(B_nd)[2]))
sum(sum(both_to_both))/(dim(both_to_both)[1] * (dim(both_to_both)[2]))
sum(sum(hansen_to_hansen))/(dim(hansen_to_hansen)[1] * (dim(hansen_to_hansen)[2]))
sum(sum(wilson_to_wilson))/(dim(wilson_to_wilson)[1] * (dim(wilson_to_wilson)[2]))
sum(sum(both_to_hansen))/(dim(both_to_hansen)[1] * dim(both_to_hansen)[2])
sum(sum(both_to_wilson))/(dim(both_to_wilson)[1] * dim(both_to_wilson)[2])
sum(sum(hansen_to_wilson))/(dim(hansen_to_wilson)[1] * dim(hansen_to_wilson)[2])
corpus |>
filter(corpus == "Both") |>
select(AU, PY) |> arrange(PY)
corpus |> tibble::rownames_to_column(var = "rownames") |> select(rownames, AB) |> unnest_tokens(word, input = "AB")
ggplot(data = layout) +
geom_point(aes(x = x,
y = y,
shape = corpus,
color = corpus),
size = 3,
alpha = 0.7) +
geom_point(data = layout |>
filter(corpus == "Both"),
aes(x = x,
y = y),
shape = 1,
size = 3) +
geom_point(data = layout |>
filter(corpus == "Wilson"),
aes(x = x,
y = y),
shape = 0,
size = 3,
alpha = 0.5) +
theme_void() +
guides(color = guide_legend(title = "Corpus"))
ggsave("Han_Wilson_bib_coupling_plot.png")
both_Han_Wilson <-
corpus |>
filter(corpus == "Both") |>
select(AU, PY) |> arrange(PY)
write.csv(both_Han_Wilson, file = "both_Han_Wilson.csv")
ggplot(data = layout) +
geom_point(aes(x = x,
y = y,
shape = corpus,
color = corpus),
size = 3,
alpha = 0.7) +
geom_point(data = layout |>
filter(corpus == "Both"),
aes(x = x,
y = y),
shape = 1,
size = 3) +
geom_point(data = layout |>
filter(corpus == "Wilson"),
aes(x = x,
y = y),
shape = 0,
size = 3,
alpha = 0.5) +
theme_void()
ggsave("Han_Wilson_bib_coupling_plot.png")
knitr::include_graphics("data-raw/Han_Wilson_bib_coupling_plot.png")
library(knitr)
library(here)
library(glue)
include_graphics(glue(here(), "/data-raw/Han_Wilson_bib_coupling_plot.png"))
citation("bibliometrix")
both_Han_Wilson <-
corpus |>
filter(corpus == "Both") |>
select(AU, PY, TI) |> arrange(PY)
write.csv(both_Han_Wilson, file = "both_Han_Wilson.csv")
corpus$PY |> unique()
