sum_D <- sum(D)
cat("Checking production, attraction balancing:\n")
cat("Production: ", sum_O, "\n")
cat("Attraction: ", sum_D, "\n")
if (sum_O != sum_D) {
cat("Productions and attractions do not balance, scaling to match.\n")
if (sum_O < sum_D) {
O <- O * (sum_D / sum_O)
} else {
D <- D * (sum_O / sum_D)
}
} else {
cat("Production, attraction balancing OK.\n")
}
n <- length(O)  # Number of i
T <- sum(O)  # Total trips
Ai <- rep(1, n)  # Initialize Ai
Bj <- rep(1, n)  # Initialize Bj
previous_error <- Inf
iteration_count <- 0
stop_reason <- ""
while (TRUE) {
iteration_count <- iteration_count + 1
# Update Ai
for (i in 1:n) {
Ai[i] <- 1 / (sum(Bj * D * impedance_matrix[i, ]) + 1e-9)
}
# Update Bj
Bj_new <- rep(1, n)
for (j in 1:n) {
Bj_new[j] <- 1 / (sum(Ai * O * impedance_matrix[, j]) + 1e-9)
}
# Calculate Tij
Tij <- outer(Ai * O, Bj_new * D) * impedance_matrix
# Print Ai and Bj for this iteration
cat("\nIteration:", iteration_count, "\n")
cat("Ai:", round(Ai, 3), "\n")
cat("Bj:", round(Bj_new, 3), "\n")
# Calculate error
error <- (sum(abs(O - rowSums(Tij))) + sum(abs(D - colSums(Tij)))) / T
# Calculate change in error
error_change <- abs(previous_error - error)
# Check stopping conditions
if (error < error_threshold) {
stop_reason <- "Error threshold met"
break
} else if (error_change < improvement_threshold) {
stop_reason <- "Slow improvement"
break
}
previous_error <- error
Bj <- Bj_new
}
# Format and print final results
return(rbind(cbind(Tij,Ai),cbind(Bj,T)))
# final_matrix <- data.frame(Tij)
# rownames(final_matrix) <- paste0("Zone ", 1:n)
# colnames(final_matrix) <- paste0("Zone ", 1:n)
# final_matrix$Origin <- rowSums(final_matrix)
# final_matrix["Destination", ] <- c(colSums(final_matrix), sum(Tij))
#
# cat("\nFinal OD Matrix:\n")
# print(round(final_matrix, 3))
# cat("\nNumber of Iterations: ", iteration_count, "\n")
# cat("Stopping Condition: ", stop_reason, "\n")
# cat(sprintf("Final Error: %.3f%%\n", error * 100))
}
t <- gravity_model(O=W_i, D=W_j, impedance_matrix = 1/C)
Tij
gravity_model <- function(
O,  # Origin production weights vector
D,  # Destination attraction weights vector
impedance_matrix,  # the resulting travel cost impedance matrix
error_threshold = 0.001,  # Error threshold for stopping condition
improvement_threshold = 1e-6  # Improvement threshold for stopping condition
) {
# Normalize O and D
sum_O <- sum(O)
sum_D <- sum(D)
cat("Checking production, attraction balancing:\n")
cat("Production: ", sum_O, "\n")
cat("Attraction: ", sum_D, "\n")
if (sum_O != sum_D) {
cat("Productions and attractions do not balance, scaling to match.\n")
if (sum_O < sum_D) {
O <- O * (sum_D / sum_O)
} else {
D <- D * (sum_O / sum_D)
}
} else {
cat("Production, attraction balancing OK.\n")
}
n <- length(O)  # Number of i
T <- sum(O)  # Total trips
Ai <- rep(1, n)  # Initialize Ai
Bj <- rep(1, n)  # Initialize Bj
previous_error <- Inf
iteration_count <- 0
stop_reason <- ""
while (TRUE) {
iteration_count <- iteration_count + 1
# Update Ai
for (i in 1:n) {
Ai[i] <- 1 / (sum(Bj * D * impedance_matrix[i, ]) + 1e-9)
}
# Update Bj
Bj_new <- rep(1, n)
for (j in 1:n) {
Bj_new[j] <- 1 / (sum(Ai * O * impedance_matrix[, j]) + 1e-9)
}
# Calculate Tij
Tij <- outer(Ai * O, Bj_new * D) * impedance_matrix
# Print Ai and Bj for this iteration
cat("\nIteration:", iteration_count, "\n")
cat("Ai:", round(Ai, 3), "\n")
cat("Bj:", round(Bj_new, 3), "\n")
# Calculate error
error <- (sum(abs(O - rowSums(Tij))) + sum(abs(D - colSums(Tij)))) / T
# Calculate change in error
error_change <- abs(previous_error - error)
# Check stopping conditions
if (error < error_threshold) {
stop_reason <- "Error threshold met"
break
} else if (error_change < improvement_threshold) {
stop_reason <- "Slow improvement"
break
}
previous_error <- error
Bj <- Bj_new
}
# Format and print final results
return(Tij)
# final_matrix <- data.frame(Tij)
# rownames(final_matrix) <- paste0("Zone ", 1:n)
# colnames(final_matrix) <- paste0("Zone ", 1:n)
# final_matrix$Origin <- rowSums(final_matrix)
# final_matrix["Destination", ] <- c(colSums(final_matrix), sum(Tij))
#
# cat("\nFinal OD Matrix:\n")
# print(round(final_matrix, 3))
# cat("\nNumber of Iterations: ", iteration_count, "\n")
# cat("Stopping Condition: ", stop_reason, "\n")
# cat(sprintf("Final Error: %.3f%%\n", error * 100))
}
t <- gravity_model(O=W_i, D=W_j, impedance_matrix = 1/C)
t
gravity_model <- function(
#CREDIT: I converted the python code from (https://github.com/SadraDaneshvar/Gravity_Model) to R
O,  # Origin production weights vector
D,  # Destination attraction weights vector
impedance_matrix,  # the resulting travel cost impedance matrix
error_threshold = 0.001,  # Error threshold for stopping condition
improvement_threshold = 1e-6  # Improvement threshold for stopping condition
) {
# Normalize O and D
sum_O <- sum(O)
sum_D <- sum(D)
cat("Checking production, attraction balancing:\n")
cat("Production: ", sum_O, "\n")
cat("Attraction: ", sum_D, "\n")
if (sum_O != sum_D) {
cat("Productions and attractions do not balance, scaling to match.\n")
if (sum_O < sum_D) {
O <- O * (sum_D / sum_O)
} else {
D <- D * (sum_O / sum_D)
}
} else {
cat("Production, attraction balancing OK.\n")
}
n <- length(O)  # Number of i
T <- sum(O)  # Total trips
Ai <- rep(1, n)  # Initialize Ai
Bj <- rep(1, n)  # Initialize Bj
previous_error <- Inf
iteration_count <- 0
stop_reason <- ""
while (TRUE) {
iteration_count <- iteration_count + 1
# Update Ai
for (i in 1:n) {
Ai[i] <- 1 / (sum(Bj * D * impedance_matrix[i, ]) + 1e-9)
}
# Update Bj
Bj_new <- rep(1, n)
for (j in 1:n) {
Bj_new[j] <- 1 / (sum(Ai * O * impedance_matrix[, j]) + 1e-9)
}
# Calculate Tij
Tij <- outer(Ai * O, Bj_new * D) * impedance_matrix
# Print Ai and Bj for this iteration
cat("\nIteration:", iteration_count, "\n")
cat("Ai:", round(Ai, 3), "\n")
cat("Bj:", round(Bj_new, 3), "\n")
# Calculate error
error <- (sum(abs(O - rowSums(Tij))) + sum(abs(D - colSums(Tij)))) / T
# Calculate change in error
error_change <- abs(previous_error - error)
# Check stopping conditions
if (error < error_threshold) {
stop_reason <- "Error threshold met"
break
} else if (error_change < improvement_threshold) {
stop_reason <- "Slow improvement"
break
}
previous_error <- error
Bj <- Bj_new
}
# Format and print final results
return(Tij)
cat("\nNumber of Iterations: ", iteration_count, "\n")
cat("Stopping Condition: ", stop_reason, "\n")
cat(sprintf("Final Error: %.3f%%\n", error * 100))
}
t <- gravity_model(O=W_i, D=W_j, impedance_matrix = 1/C)
t
rm(t)
gravity_model(O=W_i, D=W_j, impedance_matrix = 1/C)
return(Tij)
gravity_model <- function(
#CREDIT: I converted the python code from (https://github.com/SadraDaneshvar/Gravity_Model) to R
O,  # Origin production weights vector
D,  # Destination attraction weights vector
impedance_matrix,  # the resulting travel cost impedance matrix
error_threshold = 0.001,  # Error threshold for stopping condition
improvement_threshold = 1e-6  # Improvement threshold for stopping condition
) {
# Normalize O and D
sum_O <- sum(O)
sum_D <- sum(D)
cat("Checking production, attraction balancing:\n")
cat("Production: ", sum_O, "\n")
cat("Attraction: ", sum_D, "\n")
if (sum_O != sum_D) {
cat("Productions and attractions do not balance, scaling to match.\n")
if (sum_O < sum_D) {
O <- O * (sum_D / sum_O)
} else {
D <- D * (sum_O / sum_D)
}
} else {
cat("Production, attraction balancing OK.\n")
}
n <- length(O)  # Number of i
T <- sum(O)  # Total trips
Ai <- rep(1, n)  # Initialize Ai
Bj <- rep(1, n)  # Initialize Bj
previous_error <- Inf
iteration_count <- 0
stop_reason <- ""
while (TRUE) {
iteration_count <- iteration_count + 1
# Update Ai
for (i in 1:n) {
Ai[i] <- 1 / (sum(Bj * D * impedance_matrix[i, ]) + 1e-9)
}
# Update Bj
Bj_new <- rep(1, n)
for (j in 1:n) {
Bj_new[j] <- 1 / (sum(Ai * O * impedance_matrix[, j]) + 1e-9)
}
# Calculate Tij
Tij <- outer(Ai * O, Bj_new * D) * impedance_matrix
# Print Ai and Bj for this iteration
cat("\nIteration:", iteration_count, "\n")
cat("Ai:", round(Ai, 3), "\n")
cat("Bj:", round(Bj_new, 3), "\n")
# Calculate error
error <- (sum(abs(O - rowSums(Tij))) + sum(abs(D - colSums(Tij)))) / T
# Calculate change in error
error_change <- abs(previous_error - error)
# Check stopping conditions
if (error < error_threshold) {
stop_reason <- "Error threshold met"
break
} else if (error_change < improvement_threshold) {
stop_reason <- "Slow improvement"
break
}
previous_error <- error
Bj <- Bj_new
}
# Format and print final results
# final_matrix <- data.frame(Tij)
# rownames(final_matrix) <- paste0("Zone ", 1:n)
# colnames(final_matrix) <- paste0("Zone ", 1:n)
# final_matrix$Origin <- rowSums(final_matrix)
# final_matrix["Destination", ] <- c(colSums(final_matrix), sum(Tij))
#
# cat("\nFinal OD Matrix:\n")
# print(round(final_matrix, 3))
cat("\nNumber of Iterations: ", iteration_count, "\n")
cat("Stopping Condition: ", stop_reason, "\n")
cat(sprintf("Final Error: %.3f%%\n", error * 100))
return(Tij)
}
gravity_model(O=W_i, D=W_j, impedance_matrix = 1/C)
#t
rm(t)
gravity_model <- function(
#CREDIT: I converted the python code from (https://github.com/SadraDaneshvar/Gravity_Model) to R
O,  # Origin production weights vector
D,  # Destination attraction weights vector
impedance_matrix,  # the resulting travel cost impedance matrix
error_threshold = 0.001,  # Error threshold for stopping condition
improvement_threshold = 1e-6  # Improvement threshold for stopping condition
) {
# Normalize O and D
sum_O <- sum(O)
sum_D <- sum(D)
cat("Checking production, attraction balancing:\n")
cat("Production: ", sum_O, "\n")
cat("Attraction: ", sum_D, "\n")
if (sum_O != sum_D) {
cat("Productions and attractions do not balance, scaling to match.\n")
if (sum_O < sum_D) {
O <- O * (sum_D / sum_O)
} else {
D <- D * (sum_O / sum_D)
}
} else {
cat("Production, attraction balancing OK.\n")
}
n <- length(O)  # Number of i
T <- sum(O)  # Total trips
Ai <- rep(1, n)  # Initialize Ai
Bj <- rep(1, n)  # Initialize Bj
previous_error <- Inf
iteration_count <- 0
stop_reason <- ""
while (TRUE) {
iteration_count <- iteration_count + 1
# Update Ai
for (i in 1:n) {
Ai[i] <- 1 / (sum(Bj * D * impedance_matrix[i, ]) + 1e-9)
}
# Update Bj
Bj_new <- rep(1, n)
for (j in 1:n) {
Bj_new[j] <- 1 / (sum(Ai * O * impedance_matrix[, j]) + 1e-9)
}
# Calculate Tij
Tij <- outer(Ai * O, Bj_new * D) * impedance_matrix
# Print Ai and Bj for this iteration
cat("\nIteration:", iteration_count, "\n")
cat("Ai:", round(Ai, 3), "\n")
cat("Bj:", round(Bj_new, 3), "\n")
# Calculate error
error <- (sum(abs(O - rowSums(Tij))) + sum(abs(D - colSums(Tij)))) / T
# Calculate change in error
error_change <- abs(previous_error - error)
# Check stopping conditions
if (error < error_threshold) {
stop_reason <- "Error threshold met"
break
} else if (error_change < improvement_threshold) {
stop_reason <- "Slow improvement"
break
}
previous_error <- error
Bj <- Bj_new
}
# report stopping condition and final error threshold
cat("Stopping Condition: ", stop_reason, "\n")
cat(sprintf("Final Error: %.3f%%\n", error * 100))
return(Tij)
}
gravity_model(O=W_i, D=W_j, impedance_matrix = 1/C)
gravity_model <- function(
#CREDIT: I converted the python code from (https://github.com/SadraDaneshvar/Gravity_Model) to R
O,  # Origin production weights vector
D,  # Destination attraction weights vector
impedance_matrix,  # the resulting travel cost impedance matrix
error_threshold = 0.001,  # Error threshold for stopping condition
improvement_threshold = 1e-6  # Improvement threshold for stopping condition
) {
# Normalize O and D
sum_O <- sum(O)
sum_D <- sum(D)
cat("Checking production, attraction balancing:\n")
cat("Production: ", sum_O, "\n")
cat("Attraction: ", sum_D, "\n")
if (sum_O != sum_D) {
cat("Productions and attractions do not balance, scaling to match.\n")
if (sum_O < sum_D) {
O <- O * (sum_D / sum_O)
} else {
D <- D * (sum_O / sum_D)
}
} else {
cat("Production, attraction balancing OK.\n")
}
n <- length(O)  # Number of i
T <- sum(O)  # Total trips
Ai <- rep(1, n)  # Initialize Ai
Bj <- rep(1, n)  # Initialize Bj
previous_error <- Inf
iteration_count <- 0
stop_reason <- ""
while (TRUE) {
iteration_count <- iteration_count + 1
# Update Ai
for (i in 1:n) {
Ai[i] <- 1 / (sum(Bj * D * impedance_matrix[i, ]) + 1e-9)
}
# Update Bj
Bj_new <- rep(1, n)
for (j in 1:n) {
Bj_new[j] <- 1 / (sum(Ai * O * impedance_matrix[, j]) + 1e-9)
}
# Calculate Tij
Tij <- outer(Ai * O, Bj_new * D) * impedance_matrix
# Print Ai and Bj for this iteration
cat("\nIteration:", iteration_count, "\n")
cat("Ai:", round(Ai, 3), "\n")
cat("Bj:", round(Bj_new, 3), "\n")
# Calculate error
error <- (sum(abs(O - rowSums(Tij))) + sum(abs(D - colSums(Tij)))) / T
# Calculate change in error
error_change <- abs(previous_error - error)
# Check stopping conditions
if (error < error_threshold) {
stop_reason <- "Error threshold met"
break
} else if (error_change < improvement_threshold) {
stop_reason <- "Slow improvement"
break
}
previous_error <- error
Bj <- Bj_new
}
# report stopping condition and final error threshold
cat("Stopping Condition: ", stop_reason, "\n")
cat(sprintf("Final Error: %.3f%%\n", error * 100))
Tij
}
gravity_model(O=W_i, D=W_j, impedance_matrix = 1/C)
t <- gravity_model(O=W_i, D=W_j, impedance_matrix = 1/C)
t
t <- gravity_model(O=W_i, D=W_j, impedance_matrix = 1/C)
t
gravity_model <- function(
#CREDIT: I converted the python code from (https://github.com/SadraDaneshvar/Gravity_Model) to R
O,  # Origin production weights vector
D,  # Destination attraction weights vector
impedance_matrix,  # the resulting travel cost impedance matrix
error_threshold = 0.001,  # Error threshold for stopping condition
improvement_threshold = 1e-6  # Improvement threshold for stopping condition
) {
# Normalize O and D
sum_O <- sum(O)
sum_D <- sum(D)
cat("Checking production, attraction balancing:\n")
cat("Production: ", sum_O, "\n")
cat("Attraction: ", sum_D, "\n")
if (sum_O != sum_D) {
cat("Productions and attractions do not balance, scaling to match.\n")
if (sum_O < sum_D) {
O <- O * (sum_D / sum_O)
} else {
D <- D * (sum_O / sum_D)
}
} else {
cat("Production, attraction balancing OK.\n")
}
n <- length(O)  # Number of i
T <- sum(O)  # Total trips
Ai <- rep(1, n)  # Initialize Ai
Bj <- rep(1, n)  # Initialize Bj
previous_error <- Inf
iteration_count <- 0
stop_reason <- ""
while (TRUE) {
iteration_count <- iteration_count + 1
# Update Ai
for (i in 1:n) {
Ai[i] <- 1 / (sum(Bj * D * impedance_matrix[i, ]) + 1e-9)
}
# Update Bj
Bj_new <- rep(1, n)
for (j in 1:n) {
Bj_new[j] <- 1 / (sum(Ai * O * impedance_matrix[, j]) + 1e-9)
}
# Calculate Tij
Tij <- outer(Ai * O, Bj_new * D) * impedance_matrix
# Print Ai and Bj for this iteration
cat("\nIteration:", iteration_count, "\n")
cat("Ai:", round(Ai, 3), "\n")
cat("Bj:", round(Bj_new, 3), "\n")
# Calculate error
error <- (sum(abs(O - rowSums(Tij))) + sum(abs(D - colSums(Tij)))) / T
# Calculate change in error
error_change <- abs(previous_error - error)
# Check stopping conditions
if (error < error_threshold) {
stop_reason <- "Error threshold met"
break
} else if (error_change < improvement_threshold) {
stop_reason <- "Slow improvement"
break
}
previous_error <- error
Bj <- Bj_new
}
# report stopping condition and final error threshold
cat("\nStopping Condition: ", stop_reason, "\n")
cat(sprintf("Final Error: %.3f%%\n", error * 100))
}
t <- gravity_model(O=W_i, D=W_j, impedance_matrix = 1/C)
renv::status()
