prettyNum(c_w, digits = 3),
prettyNum(c_w_to_b, digits = 3)),
Both = c("-",
"-",
prettyNum(c_b, digits = 3))
) |>
gt() |>
tab_footnote(footnote = glue::glue("Average coupling for the pooled set of documents (n = {(n_h + n_w + n_b) |> prettyNum(big.mark = ",")}) is {round(c_t, 2)}")) |>
tab_options(footnotes.font.size = "small") |>
as_latex()
#| label: simple-numerical-example-opportunities-and-population
id <- c("1", "2", "3")
O_i <- c(4, 10, 6)
D_j <- c(160, 150, 180)
LU <- data.frame(id, O_i, D_j)
#| label: tbl-small-system-land-use
#| tbl-cap: "Simple system with three zones. Population is in 10,000 persons and opportunities in number of physicians."
LU |>
gt() |>
# tab_spanner("{{W[_i^(1)]}}",
#             columns = 2) |>
# tab_spanner("{{W[_j^(2)]}}",
#             columns = 3) |>
cols_label(id = "ID (i or j)",
O_i = "Population",
D_j = "Opportunities")  |>
cols_align(align = "center",
columns = 2:3) |>
tab_footnote(footnote = md("Population is *Wi^(1)^* when used as a proxy for the mass at the origin, and *Oi* when used as a constraint."),
locations = cells_column_labels(columns = O_i)) |>
tab_footnote(footnote = md("Opportunities is *Wj^(2)^* when used as a proxy for the mass at the destination, and *Dj* when used as a constraint."),
locations = cells_column_labels(columns = D_j)) |>
as_latex()
#| label: simple-numerical-example-cost
C <- expand.grid(oid = c("1", "2", "3"),
did = c("1", "2", "3")) |>
mutate(cost = c(10, 30, 15, 30, 10, 25, 15, 25, 10)) |>
mutate(f1 = cost^-3,
f2 = cost^-2,
f3 = cost^-0.1)
#| label: tbl-small-system-cost
#| tbl-cap: "Cost matrix for system with three zones (travel time in minutes)."
C |>
select(oid, did, cost) |>
tidyr::pivot_wider(names_from = did, values_from = cost) |>
gt() |>
tab_spanner(label = "Destination ID",
columns = 2:4) |>
cols_label(oid = "Origin ID")  |>
cols_align(align = "center",
columns = 2:4) |>
as_latex()
#| label: simple-numerical-example-OD-table
OD <- C |>
left_join(LU |>
select(-D_j),
by = c("oid" = "id")) |>
left_join(LU |>
select(-O_i),
by = c("did" = "id"))
#| label: tbl-simple-example-unconstrained-accessibility
#| tbl-cap: "Simple system: unconstrained accessibility."
unc_acc_ij <- OD |>
group_by(oid) |>
reframe(V_unc_ij_1 = D_j * f1,
V_unc_ij_2 = D_j * f2,
V_unc_ij_3 = D_j * f3)
unc_acc <- unc_acc_ij |>
group_by(oid) |>
summarize(V_unc_i_1 = sum(V_unc_ij_1),
V_unc_i_2 = sum(V_unc_ij_2),
V_unc_i_3 = sum(V_unc_ij_3))
unc_acc |>
gt(rowname_col = "oid") |>
tab_stubhead(label = "Origin") |>
tab_spanner(label = "{{V[_i^0]}}",
columns = 2:4,
level = 2) |>
tab_spanner(label = "{{f_1 (c_ij ) = 1/c[_ij^3]}}",
columns = 2,
level = 1) |>
tab_spanner(label = "{{f_2 (c_ij ) = 1/c[_ij^2]}}",
columns = 3,
level = 1) |>
tab_spanner(label = "{{f_3 (c_ij ) = 1/c[_ij^0.1]}}",
columns = 4,
level = 1) |>
fmt_number(decimals = 3) |>
cols_label(V_unc_i_1 = md("units: *f<sub>1</sub>(c<sub>ij</sub>)-weighted physicians*"),
V_unc_i_2 = md("units: *f<sub>2</sub>(c<sub>ij</sub>)-weighted physicians*"),
V_unc_i_3 = md("units: *f<sub>3</sub>(c<sub>ij</sub>)-weighted physicians*"),
.fn = md)  |>
# cols_label(V_unc_i_1 = "{{f_1 (c_ij ) = 1/c[_ij^3]}}",
#            V_unc_i_2 = "{{f_2 (c_ij )  = 1/c[_ij^2]}}<br>*physicians min^-2*",
#            V_unc_i_3 = "{{f_3 (c_ij )  = 1/c[_ij^0.1]}}<br>*physicians min^-0.1*",
#            .fn = md)  |>
cols_align(align = "center",
columns = 2:4) |>
cols_width(
stub() ~ px(60),
everything() ~ px(180)
) |>
grand_summary_rows(
columns = c(V_unc_i_1, V_unc_i_2, V_unc_i_3),
fns = list(label = "Sum", fn = "sum")) |>
tab_options(column_labels.font.size = "small") |>
as_latex()
# Calculate the balancing factors/proportionality constants for each of three impedance functions
k_tot <- unc_acc_ij |>
summarize(k1 = sum(LU$D_j)/sum(V_unc_ij_1), # f_1
k2 = sum(LU$D_j)/sum(V_unc_ij_2), # f_2
k3 = sum(LU$D_j)/sum(V_unc_ij_3)) # f_3
#| label: tbl-simple-example-total-opportunity-accessibility
#| tbl-cap: "Simple system: total opportunity constrained accessibility."
tot_acc_ij <- unc_acc_ij |>
mutate(V_tot_ij_1 = k_tot$k1 * V_unc_ij_1,
V_tot_ij_2 = k_tot$k2 * V_unc_ij_2,
V_tot_ij_3 = k_tot$k3 * V_unc_ij_3)
tot_acc <- tot_acc_ij |>
group_by(oid) |>
summarize(V_tot_i_1 = sum(V_tot_ij_1),
V_tot_i_2 = sum(V_tot_ij_2),
V_tot_i_3 = sum(V_tot_ij_3))
tot_acc |>
select(oid, starts_with("V_")) |>
gt(rowname_col = "oid") |>
tab_stubhead(label = "Origin") |>
tab_spanner(label = "{{V[_i^T]}}",
columns = 2:4,
level = 2) |>
tab_spanner(label = "{{f_1 (c_ij ) = 1/c[_ij^3]}}",
columns = 2,
level = 1) |>
tab_spanner(label = "{{f_2 (c_ij ) = 1/c[_ij^2]}}",
columns = 3,
level = 1) |>
tab_spanner(label = "{{f_3 (c_ij ) = 1/c[_ij^0.1]}}",
columns = 4,
level = 1) |>
fmt_number(decimals = 3) |>
cols_label(V_tot_i_1 = md("units: *physicians*"),
V_tot_i_2 = md("units: *physicians*"),
V_tot_i_3 = md("units: *physicians*"))  |>
cols_align(align = "center",
columns = 2:4) |>
cols_width(
stub() ~ px(60),
everything() ~ px(180)
) |>
tab_options(column_labels.font.size = "small") |>
grand_summary_rows(
columns = c(V_tot_i_1, V_tot_i_2, V_tot_i_3),
fns = list(label = "Sum", fn = "sum")) |>
as_latex()
# Calculate the balancing factors/proportionality constants for each of three impedance functions
unc_market_ij <- OD |>
mutate(M_unc_ij_1 = O_i * f1,
M_unc_ij_2 = O_i * f2,
M_unc_ij_3 = O_i * f3)
k_tot_pop <- unc_market_ij |>
summarize(k1 = sum(LU$O_i)/sum(M_unc_ij_1), # f_1
k2 = sum(LU$O_i)/sum(M_unc_ij_2), # f_2
k3 = sum(LU$O_i)/sum(M_unc_ij_3)) # f_3
#| label: tbl-simple-example-total-population-accessibility
#| tbl-cap: "Simple system: total opportunity constrained accessibility."
tot_pop_ij <- unc_market_ij |>
mutate(M_tot_ij_1 = k_tot_pop$k1 * M_unc_ij_1,
M_tot_ij_2 = k_tot_pop$k2 * M_unc_ij_2,
M_tot_ij_3 = k_tot_pop$k3 * M_unc_ij_3)
tot_market <- tot_pop_ij |>
group_by(did) |>
summarize(M_tot_i_1 = sum(M_tot_ij_1),
M_tot_i_2 = sum(M_tot_ij_2),
M_tot_i_3 = sum(M_tot_ij_3))
tot_market |>
select(did, starts_with("M_")) |>
gt(rowname_col = "did") |>
tab_stubhead(label = "Destination") |>
tab_spanner(label = "{{M[_i^S]}}",
columns = 2:4,
level = 2) |>
tab_spanner(label = "{{f_1 (c_ij ) = 1/c[_ij^3]}}",
columns = 2,
level = 1) |>
tab_spanner(label = "{{f_2 (c_ij ) = 1/c[_ij^2]}}",
columns = 3,
level = 1) |>
tab_spanner(label = "{{f_3 (c_ij ) = 1/c[_ij^0.1]}}",
columns = 4,
level = 1) |>
fmt_number(decimals = 3) |>
cols_label(M_tot_i_1 = md("units: *population in 10,000s*"),
M_tot_i_2 = md("units: *population in 10,000s*"),
M_tot_i_3 = md("units: *population in 10,000s*"))  |>
cols_align(align = "center",
columns = 2:4) |>
cols_width(
stub() ~ px(90),
everything() ~ px(150)
) |>
grand_summary_rows(
columns = c(M_tot_i_1, M_tot_i_2, M_tot_i_3),
fns = list(label = "Sum", fn = "sum")) |>
tab_options(column_labels.font.size = "small") |>
as_latex()
B_j <- OD |>
group_by(did) |>
summarize(B_j_1 = 1/sum(O_i * f1),
B_j_2 = 1/sum(O_i * f2),
B_j_3 = 1/sum(O_i * f3))
# B_j_longer <- B_j
# colnames(B_j_longer) <- c("ID","B_1","B_2","B_3")
# B_j_longer |> as.data.frame()  |> gt(rownames_to_stub=FALSE)
#| label: tbl-simple-example-attraction-constrained-accessibility
#| tbl-cap: "Simple system: singly-constrained opportunity accessibility."
opp_acc_ij <- OD |>
left_join(B_j,
by = "did") |>
mutate(k_opp_ij_1 = B_j_1 * O_i * f1 /3,
k_opp_ij_2 = B_j_2 * O_i  * f2 /3,
k_opp_ij_3 = B_j_3 * O_i  * f3 /3,
V_opp_ij_1 = B_j_1 * O_i * D_j * f1,
V_opp_ij_2 = B_j_2 * O_i  * D_j * f2,
V_opp_ij_3 = B_j_3 * O_i  * D_j * f3)
opp_acc <- opp_acc_ij |>
group_by(oid) |>
summarize(O_i = first(O_i) |> as.character(),
V_opp_i_1 = sum(V_opp_ij_1),
V_opp_i_2 = sum(V_opp_ij_2),
V_opp_i_3 = sum(V_opp_ij_3),
.groups = "drop")
opp_acc_with_ks <-  opp_acc_ij |>
group_by(oid) |>
summarize(O_i = first(O_i) |> as.character(),
k_opp_ij_1 = sum(k_opp_ij_1),
k_opp_ij_2 = sum(k_opp_ij_2),
k_opp_ij_3 = sum(k_opp_ij_3))
opp_acc |>
#select(oid, O_i, starts_with("V_")) |>
gt(rowname_col = "oid") |>
tab_stubhead(label = "Origin") |>
tab_spanner(label = "{{V[_i^S]}}",
columns = 3:5,
level = 2) |>
tab_spanner(label = "{{f_1 (c_ij ) = 1/c[_ij^3]}}",
columns = 3,
level = 1) |>
tab_spanner(label = "{{f_2 (c_ij ) = 1/c[_ij^2]}}",
columns = 4,
level = 1) |>
tab_spanner(label = "{{f_3 (c_ij ) = 1/c[_ij^0.1]}}",
columns = 5,
level = 1) |>
fmt_number(decimals = 3) |>
cols_label(O_i = md("Population (units: *people in 10,000s*)"),
V_opp_i_1 = md("units: *physicians*"),
V_opp_i_2 = md("units: *physicians*"),
V_opp_i_3 = md("units: *physicians*"),
)  |>
cols_align(align = "center",
columns = 2:5) |>
cols_width(
stub() ~ px(60*0.8),
everything() ~ px(180*0.8)
) |>
grand_summary_rows(
columns = c(V_opp_i_1, V_opp_i_2, V_opp_i_3),
fns = list(label = "Sum", fn = "sum")) |>
tab_options(column_labels.font.size = "small") |>
as_latex()
#| label: tbl-simple-example-attraction-constrained-accessibility-per-capita
#| tbl-cap: "Simple system: singly-constrained opportunity accessibility per capita."
opp_acc_percapita <- opp_acc |>
transmute(
oid = id,
O_i = O_i,
v_opp_i_1 = V_opp_i_1 / (O_i|>as.numeric()),
v_opp_i_2 = V_opp_i_2 / (O_i|>as.numeric()),
v_opp_i_3 = V_opp_i_3 / (O_i|>as.numeric()))
opp_acc_percapita  |>
gt(rowname_col = "oid") |>
tab_stubhead(label = "Origin") |>
tab_spanner(label = "{{v[_i^S]}}",
columns = 3:5,
level = 2) |>
tab_spanner(label = "{{f_1 (c_ij ) = 1/c[_ij^3]}}",
columns = 3,
level = 1) |>
tab_spanner(label = "{{f_2 (c_ij ) = 1/c[_ij^2]}}",
columns = 4,
level = 1) |>
tab_spanner(label = "{{f_3 (c_ij ) = 1/c[_ij^0.1]}}",
columns = 5,
level = 1) |>
fmt_number(decimals = 3) |>
cols_label(O_i = md("Population (units: *people in 10,000s*)"),
v_opp_i_1 = md("units: *physicians per capita*"),
v_opp_i_2 = md("units: *physicians per capita*"),
v_opp_i_3 = md("units: *physicians per capita*"),
)  |>
cols_align(align = "center",
columns = 2:5) |>
cols_width(
stub() ~ px(60*0.8),
everything() ~ px(180*0.8)
) |>
#grand_summary_rows(
#  columns = c(v_opp_i_1, v_opp_i_2, v_opp_i_3),
#  fns = list(label = "Sum", fn = "sum")) |>
tab_options(column_labels.font.size = "small")  |>
as_latex()
#| label: simple-numerical-example-doubly-constrained
# Same as before
id <- c("1", "2", "3")
O_i2 <- c(4, 10, 6) #in units of 10,000 people
#D_j <- c(160, 150, 180) #the old
#D_j2 <- c(6.530612, 6.122449, 7.346939) #this would be exactly linearly scaled down.
D_j2 <- c(7, 5, 8) #in units of 10,000 physician-capacity
LU2 <- data.frame(id, O_i2, D_j2)
#| label: tbl-small-system-land-use-doubly-constrained-case
#| tbl-cap: "Modified simple system with three zones reflecting matched population and opportunities. Population is in 10,000 persons and opportunities in 10,000 of physician-capacity."
LU2 |>
gt() |>
# tab_spanner("{{W[_i^(1)]}}",
#             columns = 2) |>
# tab_spanner("{{W[_j^(2)]}}",
#             columns = 3) |>
cols_label(id = "ID (i or j)",
O_i2 = "Population",
D_j2 = "Opportunities")  |>
cols_align(align = "center",
columns = 2:3) |>
as_latex()
#| label: simple-numerical-example-OD-table-doubly-constrained
OD2 <- C |># mutate(f3=100) |>
left_join(LU2 |>
select(-D_j2),
by = c("oid" = "id")) |>
left_join(LU2 |>
select(-O_i2),
by = c("did" = "id"))
doubly_constrained_gravity_model <- function(
#CREDIT: I converted the python code from (https://github.com/SadraDaneshvar/Gravity_Model) to R
O,  # Origin production weights vector
D,  # Destination attraction weights vector
impedance_matrix,  # the resulting travel cost impedance matrix
error_threshold = 0.001,  # Error threshold for stopping condition
improvement_threshold = 1e-6  # Improvement threshold for stopping condition
) {
# Normalize O and D
sum_O <- sum(O)
sum_D <- sum(D)
# cat("Checking production, attraction balancing:\n") #let's disable the messages..
# cat("Production: ", sum_O, "\n")
# cat("Attraction: ", sum_D, "\n")
if (sum_O != sum_D) {
# cat("Productions and attractions do not balance, scaling to match.\n") #let's disable the messages..
if (sum_O < sum_D) {
O <- O * (sum_D / sum_O)
} else {
D <- D * (sum_O / sum_D)
}
} else {
# cat("Production, attraction balancing OK.\n") #let's disable the messages..
}
n <- length(O)  # Number of i
T <- sum(O)  # Total trips
Ai <- rep(1, n)  # Initialize Ai
Bj <- rep(1, n)  # Initialize Bj
previous_error <- Inf
iteration_count <- 0
stop_reason <- ""
while (TRUE) {
iteration_count <- iteration_count + 1
# Update Ai
for (i in 1:n) {
Ai[i] <- 1 / (sum(Bj * D * impedance_matrix[i, ]) + 1e-9)
}
# Update Bj
Bj_new <- rep(1, n)
for (j in 1:n) {
Bj_new[j] <- 1 / (sum(Ai * O * impedance_matrix[, j]) + 1e-9)
}
# Calculate Tij
Tij <- outer(Ai * O, Bj_new * D) * impedance_matrix
# # Print Ai and Bj for this iteration #let's disable the messages..
# cat("\nIteration:", iteration_count, "\n")
# cat("Ai:", round(Ai, 3), "\n")
# cat("Bj:", round(Bj_new, 3), "\n")
# Calculate error
error <- (sum(abs(O - rowSums(Tij))) + sum(abs(D - colSums(Tij)))) / T
# Calculate change in error
error_change <- abs(previous_error - error)
# Check stopping conditions
if (error < error_threshold) {
stop_reason <- "Error threshold met"
break
} else if (error_change < improvement_threshold) {
stop_reason <- "Slow improvement"
break
}
previous_error <- error
Bj <- Bj_new
}
# report stopping condition and final error threshold #let's disable the messages..
#cat("\nStopping Condition: ", stop_reason, "\n")
#cat(sprintf("Final Error: %.3f%%\n", error * 100))
return(list(Ai = Ai, Bj = Bj, Tij = Tij))
}
#| label: calculating balancing-factors and resulting Tij for each travel behaviour scenario
#isolating impedance
Impf1 <- C$f1 |>
matrix(nrow = 3, ncol = 3)
Impf2 <- C$f2 |>
matrix(nrow = 3, ncol = 3)
Impf3 <- C$f3 |>
matrix(nrow = 3, ncol = 3)
# caclulating it
dc_acc_1 <- doubly_constrained_gravity_model(O_i2, D_j2, Impf1)
dc_acc_2 <- doubly_constrained_gravity_model(O_i2, D_j2, Impf2)
dc_acc_3 <- doubly_constrained_gravity_model(O_i2, D_j2, Impf3)
#assigning the balancing factors to their own variables
A_i_doubly1 <- dc_acc_1$Ai
B_j_doubly1 <- dc_acc_1$Bj
A_i_doubly2 <- dc_acc_2$Ai
B_j_doubly2 <- dc_acc_2$Bj
A_i_doubly3 <- dc_acc_3$Ai
B_j_doubly3 <- dc_acc_3$Bj
#assigning the Tijs to their own variables
V_dc_1 <- dc_acc_1$Tij
V_dc_2 <- dc_acc_2$Tij
V_dc_3 <- dc_acc_3$Tij
#reformatting the matrix into long format, joining it to OD2
OD2<-OD2 |> mutate(V_dc_ij_1 = c(V_dc_1[,1], V_dc_1[,2], V_dc_1[,3]),
V_dc_ij_2 = c(V_dc_2[,1], V_dc_2[,2], V_dc_2[,3]),
V_dc_ij_3 = c(V_dc_3[,1], V_dc_3[,2], V_dc_3[,3]))
OD2$k_dc_ij_1 = c((outer(A_i_doubly1 * O_i2, B_j_doubly1) * Impf1)[,1],
(outer(A_i_doubly1 * O_i2, B_j_doubly1) * Impf1)[,2],
(outer(A_i_doubly1 * O_i2, B_j_doubly1) * Impf1)[,3]) / 3
OD2$k_dc_ij_2 = c((outer(A_i_doubly2 * O_i2, B_j_doubly2) * Impf2)[,1],
(outer(A_i_doubly2 * O_i2, B_j_doubly2) * Impf2)[,2],
(outer(A_i_doubly2 * O_i2, B_j_doubly2) * Impf2)[,3]) / 3
OD2$k_dc_ij_3 = c((outer(A_i_doubly3 * O_i2, B_j_doubly3) * Impf3)[,1],
(outer(A_i_doubly3 * O_i2, B_j_doubly3) * Impf3)[,2],
(outer(A_i_doubly3 * O_i2, B_j_doubly3) * Impf3)[,3]) / 3
#Checks, should equal 1.
# OD2$k_dc_ij_1 |> sum()
# OD2$k_dc_ij_2 |> sum()
# OD2$k_dc_ij_3 |> sum()
OD2 |>
select(c(oid, did, V_dc_ij_1)) |>
tidyr::pivot_wider(names_from = did, values_from = V_dc_ij_1)
tt <- OD2 |>
select(c(oid, did, V_dc_ij_1)) |>
tidyr::pivot_wider(names_from = did, values_from = V_dc_ij_1)
OD2 |>
select(c(oid, did, V_dc_ij_1)) |>
tidyr::pivot_wider(names_from = did, values_from = V_dc_ij_1) |>
group_by(oid) |>
mutate(sum = `1` + `2` + `3`)
OD2 |>
select(c(oid, did, V_dc_ij_1)) |>
tidyr::pivot_wider(names_from = did, values_from = V_dc_ij_1) |>
group_by(oid) |>
mutate(sum = round(`1` + `2` + `3`, 0))
OD2 |>
select(c(oid, did, V_dc_ij_1)) |>
tidyr::pivot_wider(names_from = did, values_from = V_dc_ij_1) |>
group_by(oid) |>
mutate(sum = round(`1` + `2` + `3`, 0)) |>
gt() |>
tab_spanner(label = "Destination ID",
columns = 2:4) |>
cols_label(oid = "Origin ID")  |>
cols_align(align = "center",
columns = 2:4) |>
grand_summary_rows(
columns = 2:4,
fns = list(label = "Sum", fn = "sum")) |>
tab_options(column_labels.font.size = "small")
OD2 |>
select(c(oid, did, V_dc_ij_1)) |>
tidyr::pivot_wider(names_from = did, values_from = V_dc_ij_1) |>
group_by(oid) |>
mutate(sum = round(`1` + `2` + `3`, 0)) |>
gt() |>
tab_spanner(label = "Destination ID",
columns = 2:4) |>
cols_label(oid = "Origin ID")  |>
cols_align(align = "center",
columns = 2:5)
OD2 |>
select(c(oid, did, V_dc_ij_1)) |>
tidyr::pivot_wider(names_from = did, values_from = V_dc_ij_1) |>
group_by(oid) |>
mutate(sum = round(`1` + `2` + `3`, 0)) |>
gt() |>
tab_spanner(label = "Destination ID",
columns = 2:4)
OD2 |>
select(c(oid, did, V_dc_ij_1)) |>
tidyr::pivot_wider(names_from = did, values_from = V_dc_ij_1) |>
group_by(oid) |>
mutate(sum = round(`1` + `2` + `3`, 0)) |>
gt()
OD2 |>
select(c(oid, did, V_dc_ij_1)) |>
tidyr::pivot_wider(names_from = did, values_from = V_dc_ij_1) |>
group_by(oid) |>
mutate(sum = round(`1` + `2` + `3`, 0)) |>
ungroup() |>
gt()
