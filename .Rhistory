previous_error <- Inf
iteration_count <- 0
stop_reason <- ""
while (TRUE) {
iteration_count <- iteration_count + 1
# Update Ai
for (i in 1:n) {
Ai[i] <- 1 / (sum(Bj * D * impedance_matrix[i, ]) + 1e-9)
}
# Update Bj
Bj_new <- rep(1, n)
for (j in 1:n) {
Bj_new[j] <- 1 / (sum(Ai * O * impedance_matrix[, j]) + 1e-9)
}
# Calculate Tij
Tij <- outer(Ai, Bj_new * D) * impedance_matrix
# Print Ai and Bj for this iteration
cat("\nIteration:", iteration_count, "\n")
cat("Ai:", round(Ai, 3), "\n")
cat("Bj:", round(Bj_new, 3), "\n")
# Calculate error
error <- (sum(abs(O - rowSums(Tij))) + sum(abs(D - colSums(Tij)))) / T
# Calculate change in error
error_change <- abs(previous_error - error)
# Check stopping conditions
if (error < error_threshold) {
stop_reason <- "Error threshold met"
break
} else if (error_change < improvement_threshold) {
stop_reason <- "Slow improvement"
break
}
previous_error <- error
Bj <- Bj_new
}
# report stopping condition and final error threshold
cat("\nStopping Condition: ", stop_reason, "\n")
cat(sprintf("Final Error: %.3f%%\n", error * 100))
return(list(Ai = Ai, Bj = Bj, Tij = Tij))
}
dc_results <- doubly_constrained_gravity_model(O=P_i, D=O_j, impedance_matrix = 1/C)
dc_results$Tij
# Calculate Tij
Tij <- (Ai * Bj_new * D) * impedance_matrix
doubly_constrained_gravity_model <- function(
#CREDIT: I converted the python code from (https://github.com/SadraDaneshvar/Gravity_Model) to R
O,  # Origin production weights vector
D,  # Destination attraction weights vector
impedance_matrix,  # the resulting travel cost impedance matrix
error_threshold = 0.001,  # Error threshold for stopping condition
improvement_threshold = 1e-6  # Improvement threshold for stopping condition
) {
# Normalize O and D
sum_O <- sum(O)
sum_D <- sum(D)
cat("Checking production, attraction balancing:\n")
cat("Production: ", sum_O, "\n")
cat("Attraction: ", sum_D, "\n")
if (sum_O != sum_D) {
cat("Productions and attractions do not balance, scaling to match.\n")
if (sum_O < sum_D) {
O <- O * (sum_D / sum_O)
} else {
D <- D * (sum_O / sum_D)
}
} else {
cat("Production, attraction balancing OK.\n")
}
n <- length(O)  # Number of i
T <- sum(O)  # Total trips
Ai <- rep(1, n)  # Initialize Ai
Bj <- rep(1, n)  # Initialize Bj
previous_error <- Inf
iteration_count <- 0
stop_reason <- ""
while (TRUE) {
iteration_count <- iteration_count + 1
# Update Ai
for (i in 1:n) {
Ai[i] <- 1 / (sum(Bj * D * impedance_matrix[i, ]) + 1e-9)
}
# Update Bj
Bj_new <- rep(1, n)
for (j in 1:n) {
Bj_new[j] <- 1 / (sum(Ai * O * impedance_matrix[, j]) + 1e-9)
}
# Calculate Tij
Tij <- (Ai * Bj_new * D) * impedance_matrix
# Print Ai and Bj for this iteration
cat("\nIteration:", iteration_count, "\n")
cat("Ai:", round(Ai, 3), "\n")
cat("Bj:", round(Bj_new, 3), "\n")
# Calculate error
error <- (sum(abs(O - rowSums(Tij))) + sum(abs(D - colSums(Tij)))) / T
# Calculate change in error
error_change <- abs(previous_error - error)
# Check stopping conditions
if (error < error_threshold) {
stop_reason <- "Error threshold met"
break
} else if (error_change < improvement_threshold) {
stop_reason <- "Slow improvement"
break
}
previous_error <- error
Bj <- Bj_new
}
# report stopping condition and final error threshold
cat("\nStopping Condition: ", stop_reason, "\n")
cat(sprintf("Final Error: %.3f%%\n", error * 100))
return(list(Ai = Ai, Bj = Bj, Tij = Tij))
}
dc_results <- doubly_constrained_gravity_model(O=P_i, D=O_j, impedance_matrix = 1/C)
dc_results$Tij
doubly_constrained_gravity_model <- function(
#CREDIT: I converted the python code from (https://github.com/SadraDaneshvar/Gravity_Model) to R
O,  # Origin production weights vector
D,  # Destination attraction weights vector
impedance_matrix,  # the resulting travel cost impedance matrix
error_threshold = 0.001,  # Error threshold for stopping condition
improvement_threshold = 1e-6  # Improvement threshold for stopping condition
) {
# Normalize O and D
sum_O <- sum(O)
sum_D <- sum(D)
cat("Checking production, attraction balancing:\n")
cat("Production: ", sum_O, "\n")
cat("Attraction: ", sum_D, "\n")
if (sum_O != sum_D) {
cat("Productions and attractions do not balance, scaling to match.\n")
if (sum_O < sum_D) {
O <- O * (sum_D / sum_O)
} else {
D <- D * (sum_O / sum_D)
}
} else {
cat("Production, attraction balancing OK.\n")
}
n <- length(O)  # Number of i
T <- sum(O)  # Total trips
Ai <- rep(1, n)  # Initialize Ai
Bj <- rep(1, n)  # Initialize Bj
previous_error <- Inf
iteration_count <- 0
stop_reason <- ""
while (TRUE) {
iteration_count <- iteration_count + 1
# Update Ai
for (i in 1:n) {
Ai[i] <- 1 / (sum(Bj * D * impedance_matrix[i, ]) + 1e-9)
}
# Update Bj
Bj_new <- rep(1, n)
for (j in 1:n) {
Bj_new[j] <- 1 / (sum(Ai * O * impedance_matrix[, j]) + 1e-9)
}
# Calculate Tij
Tij <- outer(Ai, Bj_new * D) * impedance_matrix #Tij <- outer(Ai * O, Bj_new * D) * impedance_matrix -->
# Print Ai and Bj for this iteration
cat("\nIteration:", iteration_count, "\n")
cat("Ai:", round(Ai, 3), "\n")
cat("Bj:", round(Bj_new, 3), "\n")
# Calculate error
error <- (sum(abs(O - rowSums(Tij))) + sum(abs(D - colSums(Tij)))) / T
# Calculate change in error
error_change <- abs(previous_error - error)
# Check stopping conditions
if (error < error_threshold) {
stop_reason <- "Error threshold met"
break
} else if (error_change < improvement_threshold) {
stop_reason <- "Slow improvement"
break
}
previous_error <- error
Bj <- Bj_new
}
# report stopping condition and final error threshold
cat("\nStopping Condition: ", stop_reason, "\n")
cat(sprintf("Final Error: %.3f%%\n", error * 100))
return(list(Ai = Ai, Bj = Bj, Tij = Tij))
}
dc_results <- doubly_constrained_gravity_model(O=P_i, D=O_j, impedance_matrix = 1/C)
dc_results$Tij
doubly_constrained_gravity_model <- function(
#CREDIT: I converted the python code from (https://github.com/SadraDaneshvar/Gravity_Model) to R
O,  # Origin production weights vector
D,  # Destination attraction weights vector
impedance_matrix,  # the resulting travel cost impedance matrix
error_threshold = 0.001,  # Error threshold for stopping condition
improvement_threshold = 1e-6  # Improvement threshold for stopping condition
) {
# Normalize O and D
sum_O <- sum(O)
sum_D <- sum(D)
cat("Checking production, attraction balancing:\n")
cat("Production: ", sum_O, "\n")
cat("Attraction: ", sum_D, "\n")
if (sum_O != sum_D) {
cat("Productions and attractions do not balance, scaling to match.\n")
if (sum_O < sum_D) {
O <- O * (sum_D / sum_O)
} else {
D <- D * (sum_O / sum_D)
}
} else {
cat("Production, attraction balancing OK.\n")
}
n <- length(O)  # Number of i
T <- sum(O)  # Total trips
Ai <- rep(1, n)  # Initialize Ai
Bj <- rep(1, n)  # Initialize Bj
previous_error <- Inf
iteration_count <- 0
stop_reason <- ""
while (TRUE) {
iteration_count <- iteration_count + 1
# Update Ai
for (i in 1:n) {
Ai[i] <- 1 / (sum(Bj * D * impedance_matrix[i, ]) + 1e-9)
}
# Update Bj
Bj_new <- rep(1, n)
for (j in 1:n) {
Bj_new[j] <- 1 / (sum(Ai * O * impedance_matrix[, j]) + 1e-9)
}
# Calculate Tij
Tij <- outer(Ai * O, Bj_new * D) * impedance_matrix #Tij <- outer(Ai * O, Bj_new * D) * impedance_matrix -->
# Print Ai and Bj for this iteration
cat("\nIteration:", iteration_count, "\n")
cat("Ai:", round(Ai, 3), "\n")
cat("Bj:", round(Bj_new, 3), "\n")
# Calculate error
error <- (sum(abs(O - rowSums(Tij))) + sum(abs(D - colSums(Tij)))) / T
# Calculate change in error
error_change <- abs(previous_error - error)
# Check stopping conditions
if (error < error_threshold) {
stop_reason <- "Error threshold met"
break
} else if (error_change < improvement_threshold) {
stop_reason <- "Slow improvement"
break
}
previous_error <- error
Bj <- Bj_new
}
# report stopping condition and final error threshold
cat("\nStopping Condition: ", stop_reason, "\n")
cat(sprintf("Final Error: %.3f%%\n", error * 100))
return(list(Ai = Ai, Bj = Bj, Tij = Tij))
}
dc_results <- doubly_constrained_gravity_model(O=P_i, D=O_j, impedance_matrix = 1/C)
dc_results$Tij
dc_results
dc_results
dc_results$Ai
dc_results$Bj
dc_results
doubly_constrained_gravity_model <- function(
#CREDIT: I converted the python code from (https://github.com/SadraDaneshvar/Gravity_Model) to R
O,  # Origin production weights vector
D,  # Destination attraction weights vector
impedance_matrix,  # the resulting travel cost impedance matrix
error_threshold = 0.001,  # Error threshold for stopping condition
improvement_threshold = 1e-6  # Improvement threshold for stopping condition
) {
# Normalize O and D
sum_O <- sum(O)
sum_D <- sum(D)
cat("Checking production, attraction balancing:\n")
cat("Production: ", sum_O, "\n")
cat("Attraction: ", sum_D, "\n")
if (sum_O != sum_D) {
cat("Productions and attractions do not balance, scaling to match.\n")
if (sum_O < sum_D) {
O <- O * (sum_D / sum_O)
} else {
D <- D * (sum_O / sum_D)
}
} else {
cat("Production, attraction balancing OK.\n")
}
n <- length(O)  # Number of i
T <- sum(O)  # Total trips
Ai <- rep(1, n)  # Initialize Ai
Bj <- rep(1, n)  # Initialize Bj
previous_error <- Inf
iteration_count <- 0
stop_reason <- ""
while (TRUE) {
iteration_count <- iteration_count + 1
# Update Ai
for (i in 1:n) {
Ai[i] <- 1 / (sum(Bj * D * impedance_matrix[i, ]) + 1e-9)
}
# Update Bj
Bj_new <- rep(1, n)
for (j in 1:n) {
Bj_new[j] <- 1 / (sum(Ai * O * impedance_matrix[, j]) + 1e-9)
}
# Calculate Tij
Tij <- outer(Ai, Bj_new * D) * impedance_matrix #Tij <- outer(Ai * O, Bj_new * D) * impedance_matrix -->
# Print Ai and Bj for this iteration
cat("\nIteration:", iteration_count, "\n")
cat("Ai:", round(Ai, 3), "\n")
cat("Bj:", round(Bj_new, 3), "\n")
# Calculate error
error <- (sum(abs(O - rowSums(Tij))) + sum(abs(D - colSums(Tij)))) / T
# Calculate change in error
error_change <- abs(previous_error - error)
# Check stopping conditions
if (error < error_threshold) {
stop_reason <- "Error threshold met"
break
} else if (error_change < improvement_threshold) {
stop_reason <- "Slow improvement"
break
}
previous_error <- error
Bj <- Bj_new
}
# report stopping condition and final error threshold
cat("\nStopping Condition: ", stop_reason, "\n")
cat(sprintf("Final Error: %.3f%%\n", error * 100))
return(list(Ai = Ai, Bj = Bj, Tij = Tij))
}
dc_results <- doubly_constrained_gravity_model(O=P_i, D=O_j, impedance_matrix = 1/C)
dc_results$Tij
A_i_doubly <- dc_results$Ai
B_j_doubly <- dc_results$Bj
A_i_doubly |> matrix()
B_j_doubly |> matrix() |> t()
V_doubly <- dc_results$Tij
P_i_doubly <- V_doubly |> rowSums()
O_j_doubly <- V_doubly |> colSums()
V_TOTAL_dest <- ifelse(sum(P_i_doubly)==sum(O_j_doubly), sum(V_doubly), NA)
V_doubly_longer <- cbind(V_doubly,P_i_dest)
V_doubly <- dc_results$Tij
P_i_doubly <- V_doubly |> rowSums()
O_j_doubly <- V_doubly |> colSums()
V_TOTAL_dest <- ifelse(sum(P_i_doubly)==sum(O_j_doubly), sum(V_doubly), NA)
V_doubly_longer <- cbind(V_doubly,P_i_dest)
V_doubly <- dc_results$Tij
P_i_doubly <- V_doubly |> rowSums()
O_j_doubly <- V_doubly |> colSums()
V_TOTAL_dest <- ifelse(sum(P_i_doubly)==sum(O_j_doubly), sum(V_doubly), NA)
V_doubly_longer <- cbind(V_doubly,P_i_doubly)
V_doubly_longer <- rbind(V_doubly_longer, cbind(t(O_j_doubly),V_TOTAL_dest))
rownames(V_doubly_longer) <- c("1","2","3", "TOTAL")
colnames(V_doubly_longer) <- c("1","2","3", "TOTAL")
V_doubly_longer |> round() #|> as.data.frame()  |> gt(rownames_to_stub=TRUE)
doubly_constrained_gravity_model <- function(
#CREDIT: I converted the python code from (https://github.com/SadraDaneshvar/Gravity_Model) to R
O,  # Origin production weights vector
D,  # Destination attraction weights vector
impedance_matrix,  # the resulting travel cost impedance matrix
error_threshold = 0.001,  # Error threshold for stopping condition
improvement_threshold = 1e-6  # Improvement threshold for stopping condition
) {
# Normalize O and D
sum_O <- sum(O)
sum_D <- sum(D)
cat("Checking production, attraction balancing:\n")
cat("Production: ", sum_O, "\n")
cat("Attraction: ", sum_D, "\n")
if (sum_O != sum_D) {
cat("Productions and attractions do not balance, scaling to match.\n")
if (sum_O < sum_D) {
O <- O * (sum_D / sum_O)
} else {
D <- D * (sum_O / sum_D)
}
} else {
cat("Production, attraction balancing OK.\n")
}
n <- length(O)  # Number of i
T <- sum(O)  # Total trips
Ai <- rep(1, n)  # Initialize Ai
Bj <- rep(1, n)  # Initialize Bj
previous_error <- Inf
iteration_count <- 0
stop_reason <- ""
while (TRUE) {
iteration_count <- iteration_count + 1
# Update Ai
for (i in 1:n) {
Ai[i] <- 1 / (sum(Bj * D * impedance_matrix[i, ]) + 1e-9)
}
# Update Bj
Bj_new <- rep(1, n)
for (j in 1:n) {
Bj_new[j] <- 1 / (sum(Ai * O * impedance_matrix[, j]) + 1e-9)
}
# Calculate Tij
Tij <- outer(Ai * O, Bj_new * D) * impedance_matrix #Tij <- outer(Ai * O, Bj_new * D) * impedance_matrix -->
# Print Ai and Bj for this iteration
cat("\nIteration:", iteration_count, "\n")
cat("Ai:", round(Ai, 3), "\n")
cat("Bj:", round(Bj_new, 3), "\n")
# Calculate error
error <- (sum(abs(O - rowSums(Tij))) + sum(abs(D - colSums(Tij)))) / T
# Calculate change in error
error_change <- abs(previous_error - error)
# Check stopping conditions
if (error < error_threshold) {
stop_reason <- "Error threshold met"
break
} else if (error_change < improvement_threshold) {
stop_reason <- "Slow improvement"
break
}
previous_error <- error
Bj <- Bj_new
}
# report stopping condition and final error threshold
cat("\nStopping Condition: ", stop_reason, "\n")
cat(sprintf("Final Error: %.3f%%\n", error * 100))
return(list(Ai = Ai, Bj = Bj, Tij = Tij))
}
dc_results <- doubly_constrained_gravity_model(O=P_i, D=O_j, impedance_matrix = 1/C)
dc_results$Tij
A_i_doubly <- dc_results$Ai
B_j_doubly <- dc_results$Bj
A_i_doubly |> matrix()
B_j_doubly |> matrix() |> t()
V_doubly <- dc_results$Tij
P_i_doubly <- V_doubly |> rowSums()
O_j_doubly <- V_doubly |> colSums()
V_TOTAL_dest <- ifelse(sum(P_i_doubly)==sum(O_j_doubly), sum(V_doubly), NA)
V_doubly_longer <- cbind(V_doubly,P_i_doubly)
V_doubly_longer <- rbind(V_doubly_longer, cbind(t(O_j_doubly),V_TOTAL_dest))
rownames(V_doubly_longer) <- c("1","2","3", "TOTAL")
colnames(V_doubly_longer) <- c("1","2","3", "TOTAL")
V_doubly_longer |> round() #|> as.data.frame()  |> gt(rownames_to_stub=TRUE)
B_ij <- matrix(P_i) %*% (1/(t((matrix(P_i))) %*% (1/C)))
B_ij_longer <- B_ij
rownames(B_ij_longer) <- c("1","2","3")
colnames(B_ij_longer) <- c("1","2","3")
B_ij_longer
knitr::opts_chunk$set(
echo = FALSE,
cache = FALSE,
warning = FALSE,
message = FALSE,
comment = '',
out.width = "1\\linewidth")
library(dplyr) # A Grammar of Data Manipulation
library(ggplot2) # Create Elegant Data Visualisations Using the Grammar of Graphics
library(flextable)
library(knitr)
library(glue)
library(here)
# library(huxtable) # Easily Create and Style Tables for LaTeX, HTML and Other Formats
# library(kableExtra) # Construct Complex Table with 'kable' and Pipe Syntax
# library(patchwork) # The Composer of Plots
# library(RColorBrewer) # ColorBrewer Palettes
# library(sf) # Simple Features for R
# library(scales) # Scale Functions for Visualization
# library(shadowtext) # Shadow Text Grob and Layer
# library(skimr) # Compact and Flexible Summaries of Data
# library(spdep) # Spatial Dependence: Weighting Schemes, Statistics
# library(tidyr) # Tidy Messy Data
# library(tmap) # Thematic Maps
# library(ggpmisc) # Miscellaneous Extensions to 'ggplot2'
# library(ggrepel) # Automatically Position Non-Overlapping Text Labels with 'ggplot2'
# library(ggspatial) # Spatial Data Framework for ggplot2
# library(gridExtra) # Miscellaneous Functions for "Grid" Graphics
# library(here)
#| label: fig-Fig1
#| fig-cap: "The bibliometric coupling of papers that cite Hansen (1959), Wilson (1971) and both Hansen (1959) and Wilson (1971)."
include_graphics(glue(here(), "/data-raw/Han_Wilson_bib_coupling_plot.png"))
known_matrix <- matrix(c(95,23,42, 27,378,45, 38,36,106), ncol = 3, byrow = TRUE)
#unknowns <- matrix(c(rep(NA,9)), ncol=3, byrow=TRUE)
P_i <- known_matrix |> rowSums()
O_j <- known_matrix |> colSums()
V <- ifelse(sum(P_i)==sum(O_j), sum(O_j),NA)
knowns_longer <- cbind(known_matrix,P_i)
knowns_longer <- rbind(knowns_longer,cbind(t(O_j),T))
rownames(knowns_longer) <- c("1","2","3", "TOTAL")
colnames(knowns_longer) <- c("1","2","3", "TOTAL")
knowns_longer #|> as.data.frame() |> round() |> gt(rownames_to_stub=TRUE)
C <- matrix(c(2, 15, 5, 15, 2, 10, 5, 10, 2), ncol = 3, byrow = TRUE)
C_longer <-C
rownames(C_longer) <- c("1","2","3")
colnames(C_longer) <- c("1","2","3")
C_longer #|> as.data.frame() |> gt(rownames_to_stub=TRUE)
O_P_unc <- t(matrix(rep(O_j, 3), 3, 3))
O_P_unc_longer <- O_P_unc
rownames(O_P_unc_longer) <- c("1","2","3")
colnames(O_P_unc_longer) <- c("1","2","3")
O_P_unc_longer
V_unc <- O_P_unc / C
P_i_unc <- V_unc |> rowSums()
O_j_unc <- V_unc |> colSums()
V_TOTAL_unc <- ifelse(sum(P_i_unc|>round())==sum(O_j_unc|>round()), sum(V_unc), NA)
V_unc_longer <- cbind(V_unc,P_i_unc)
V_unc_longer <- rbind(V_unc_longer, cbind(t(O_j_unc),V_TOTAL_unc))
rownames(V_unc_longer) <- c("1","2","3", "TOTAL")
colnames(V_unc_longer) <- c("1","2","3", "TOTAL")
V_unc_longer |> round(digits = 2) #|> as.data.frame()  |> gt(rownames_to_stub=TRUE)
300*200
200/400
1/500 * 300
1/500 * 300 * 300
(1/500) * 300 * 300
(1/500) * 300 * 200
(1/500) * 200 * 200
(1/500) * 200 * 300
(1/500) * 200 * 200
120+80
120+180
